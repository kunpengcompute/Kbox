Copyright (C) 2021. Huawei Technologies Co., Ltd. 

This program is free software; you can redistribute it and/or modify
it under the terms of the Apache License, Version 2.0 and
only version 2 as published by the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
Apache 2.0 for more details.




diff --git a/adb/daemon/main.cpp b/adb/daemon/main.cpp
index 5adeb4446..e4c1105d0 100644
--- a/adb/daemon/main.cpp
+++ b/adb/daemon/main.cpp
@@ -153,11 +153,13 @@ static void drop_privileges(int server_port) {
         // minijail_enter() will abort if any priv-dropping step fails.
         minijail_enter(jail.get());
 
+#if 0
         if (root_seclabel != nullptr) {
             if (selinux_android_setcon(root_seclabel) < 0) {
                 LOG(FATAL) << "Could not set SELinux context";
             }
         }
+#endif
         std::string error;
         std::string local_name =
             android::base::StringPrintf("tcp:%d", server_port);
diff --git a/init/log.cpp b/init/log.cpp
index 6198fc25f..70af27c36 100644
--- a/init/log.cpp
+++ b/init/log.cpp
@@ -53,6 +53,7 @@ static void InitAborter(const char* abort_message) {
 }
 
 void InitKernelLogging(char* argv[]) {
+#if 0
     // Make stdin/stdout/stderr all point to /dev/null.
     int fd = open("/sys/fs/selinux/null", O_RDWR);
     if (fd == -1) {
@@ -65,6 +66,7 @@ void InitKernelLogging(char* argv[]) {
     dup2(fd, 1);
     dup2(fd, 2);
     if (fd > 2) close(fd);
+#endif
 
     android::base::InitLogging(argv, &android::base::KernelLogger, InitAborter);
 }
diff --git a/init/property_service.cpp b/init/property_service.cpp
index 4172ba754..c845e289a 100644
--- a/init/property_service.cpp
+++ b/init/property_service.cpp
@@ -471,9 +471,11 @@ uint32_t HandlePropertySet(const std::string& name, const std::string& value,
                   << process_log_string;
     }
 
+#if 0
     if (name == "selinux.restorecon_recursive") {
         return PropertySetAsync(name, value, RestoreconRecursiveAsync, error);
     }
+#endif
 
     return PropertySet(name, value, error);
 }
@@ -838,9 +840,11 @@ void CreateSerializedPropertyInfo() {
 }
 
 void start_property_service() {
+#if 0
     selinux_callback cb;
     cb.func_audit = SelinuxAuditCallback;
     selinux_set_callback(SELINUX_CB_AUDIT, cb);
+#endif
 
     property_set("ro.property_service.version", "2");
 
diff --git a/init/selinux.cpp b/init/selinux.cpp
index 0ba5c4ae3..276bfec93 100644
--- a/init/selinux.cpp
+++ b/init/selinux.cpp
@@ -89,10 +89,13 @@ EnforcingStatus StatusFromCmdline() {
 }
 
 bool IsEnforcing() {
+#if 0
     if (ALLOW_PERMISSIVE_SELINUX) {
         return StatusFromCmdline() == SELINUX_ENFORCING;
     }
     return true;
+#endif
+    return false; // permissive
 }
 
 // Forks, executes the provided program in the child, and waits for the completion in the parent.
@@ -457,6 +460,9 @@ void SelinuxSetupKernelLogging() {
 
 // This function checks whether the sepolicy supports vendor init.
 bool SelinuxHasVendorInit() {
+    if (true) {
+        return false;
+    }
     if (!IsSplitPolicyDevice()) {
         // If this device does not split sepolicy files, vendor_init will be available in the latest
         // monolithic sepolicy file.
diff --git a/init/init.cpp b/init/init.cpp
index e94e1c1..fa22ee8 100644
--- a/init/init.cpp
+++ b/init/init.cpp
@@ -586,7 +586,7 @@ int main(int argc, char** argv) {
         // gid_t groups[] = { AID_READPROC };
         // setgroups(arraysize(groups), groups);
         mount("sysfs", "/sys", "sysfs", 0, NULL);
-        mount("selinuxfs", "/sys/fs/selinux", "selinuxfs", 0, NULL);
+        // mount("selinuxfs", "/sys/fs/selinux", "selinuxfs", 0, NULL);
 
         mknod("/dev/kmsg", S_IFCHR | 0600, makedev(1, 11));
 
@@ -620,6 +620,7 @@ int main(int argc, char** argv) {
         // Enable seccomp if global boot option was passed (otherwise it is enabled in zygote).
         global_seccomp();
 
+#if 0
         // Set up SELinux, loading the SELinux policy.
         SelinuxSetupKernelLogging();
         SelinuxInitialize();
@@ -630,6 +631,7 @@ int main(int argc, char** argv) {
             PLOG(FATAL) << "restorecon failed of /init failed";
         }
 
+#endif
         setenv("INIT_SECOND_STAGE", "true", 1);
 
         static constexpr uint32_t kNanosecondsPerMillisecond = 1e6;
@@ -646,7 +648,7 @@ int main(int argc, char** argv) {
     }
 
     // At this point we're in the second stage of init.
-    InitKernelLogging(argv);
+    // InitKernelLogging(argv);
     LOG(INFO) << "init second stage started!";
 
     // Set up a session keyring that all processes will have access to. It
@@ -672,7 +674,7 @@ int main(int argc, char** argv) {
 
     // Make the time that init started available for bootstat to log.
     // property_set("ro.boottime.init", getenv("INIT_STARTED_AT"));//getenv("INIT_STARTED_AT") = null
-    property_set("ro.boottime.init.selinux", getenv("INIT_SELINUX_TOOK"));
+    // property_set("ro.boottime.init.selinux", getenv("INIT_SELINUX_TOOK"));
 
     // Set libavb version for Framework-only OTA match in Treble build.
     // const char* avb_version = getenv("INIT_AVB_VERSION");
@@ -684,10 +686,12 @@ int main(int argc, char** argv) {
     unsetenv("INIT_SELINUX_TOOK");
     unsetenv("INIT_AVB_VERSION");
 
+#if 0
     // Now set up SELinux for second stage.
     SelinuxSetupKernelLogging();
     SelabelInitialize();
     SelinuxRestoreContext();
+#endif
 
     epoll_fd = epoll_create1(EPOLL_CLOEXEC);
     if (epoll_fd == -1) {
diff --git a/init/ueventd.cpp b/init/ueventd.cpp
index fd0b744..e2fe82a 100644
--- a/init/ueventd.cpp
+++ b/init/ueventd.cpp
@@ -260,8 +260,8 @@ int ueventd_main(int argc, char** argv) {
 
     LOG(INFO) << "ueventd started!";
 
-    SelinuxSetupKernelLogging();
-    SelabelInitialize();
+    // SelinuxSetupKernelLogging();
+    // SelabelInitialize();
 
     DeviceHandler device_handler = CreateDeviceHandler();
     UeventListener uevent_listener;