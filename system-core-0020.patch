diff --git a/adb/adb_trace.h b/adb/adb_trace.h
index 1d2c8c704..7d49d3893 100644
--- a/adb/adb_trace.h
+++ b/adb/adb_trace.h
@@ -44,9 +44,6 @@ enum AdbTrace {
     ((adb_trace_mask & (1 << (TAG))) != 0)
 
 #define VLOG(TAG)                 \
-    if (LIKELY(!VLOG_IS_ON(TAG))) \
-        ;                         \
-    else                          \
         LOG(DEBUG)
 
 // You must define TRACE_TAG before using this macro.
diff --git a/adb/daemon/main.cpp b/adb/daemon/main.cpp
index 5adeb4446..e4c1105d0 100644
--- a/adb/daemon/main.cpp
+++ b/adb/daemon/main.cpp
@@ -153,11 +153,13 @@ static void drop_privileges(int server_port) {
         // minijail_enter() will abort if any priv-dropping step fails.
         minijail_enter(jail.get());
 
+#if 0
         if (root_seclabel != nullptr) {
             if (selinux_android_setcon(root_seclabel) < 0) {
                 LOG(FATAL) << "Could not set SELinux context";
             }
         }
+#endif
         std::string error;
         std::string local_name =
             android::base::StringPrintf("tcp:%d", server_port);
diff --git a/adb/sockets.cpp b/adb/sockets.cpp
index 04bd0804e..cd278f738 100644
--- a/adb/sockets.cpp
+++ b/adb/sockets.cpp
@@ -336,6 +336,7 @@ static void local_socket_event_func(int fd, unsigned ev, void* _s) {
 
 asocket* create_local_socket(int fd) {
     asocket* s = new asocket();
+    disable_tcp_nagle(fd);
     s->fd = fd;
     s->enqueue = local_socket_enqueue;
     s->ready = local_socket_ready;
diff --git a/adb/transport_local.cpp b/adb/transport_local.cpp
index 560a0312b..e186c87ab 100644
--- a/adb/transport_local.cpp
+++ b/adb/transport_local.cpp
@@ -234,7 +234,7 @@ static void server_socket_thread(int port) {
             close_on_exec(fd);
             disable_tcp_nagle(fd);
             std::string serial = android::base::StringPrintf("host-%d", fd);
-            if (register_socket_transport(fd, serial.c_str(), port, 1) != 0) {
+            if (register_socket_transport(fd, nullptr, port, 1) != 0) {
                 adb_close(fd);
             }
         }
@@ -253,6 +253,7 @@ static void server_socket_thread(int port) {
 #define open    adb_open
 #define read    adb_read
 #define write   adb_write
+#define QEMU_PIPE_FROM_ADB
 #include <qemu_pipe.h>
 #undef open
 #undef read
@@ -305,6 +306,7 @@ static void qemu_socket_thread(int port) {
     D("transport: qemu_socket_thread() starting");
 
     /* adb QEMUD service connection request. */
+    std::thread(server_socket_thread, port).detach();
     snprintf(con_name, sizeof(con_name), "pipe:qemud:adb:%d", port);
 
     /* Connect to the adb QEMUD service. */
@@ -313,7 +315,7 @@ static void qemu_socket_thread(int port) {
         /* This could be an older version of the emulator, that doesn't
          * implement adb QEMUD service. Fall back to the old TCP way. */
         D("adb service is not available. Falling back to TCP socket.");
-        std::thread(server_socket_thread, port).detach();
+        //std::thread(server_socket_thread, port).detach();
         return;
     }
 
diff --git a/init/Android.bp b/init/Android.bp
index 70a4ac651..1c20174e4 100644
--- a/init/Android.bp
+++ b/init/Android.bp
@@ -132,6 +132,13 @@ cc_library_static {
         type: "lite",
         export_proto_headers: true,
     },
+    cflags: [
+        "-Wall",
+        "-Werror",
+        "-Wno-unused-parameter",
+        "-Wno-unused-function",
+    ],
+
 }
 
 /*
diff --git a/init/Android.mk b/init/Android.mk
index c4a6a50e5..dc030b819 100644
--- a/init/Android.mk
+++ b/init/Android.mk
@@ -36,6 +36,7 @@ init_cflags += \
     -Wno-unused-parameter \
     -Werror \
     -std=gnu++1z \
+    -Wno-unused-function
 
 # --
 
diff --git a/init/devices.cpp b/init/devices.cpp
index ada1e2870..0d0b1092e 100644
--- a/init/devices.cpp
+++ b/init/devices.cpp
@@ -220,6 +220,15 @@
     return {0600, 0, 0};
 }

+void DeviceHandler::chinit_dev(const char *path)
+{
+    std::vector<std::string> links;
+    auto[mode, uid, gid] = GetDevicePermissions(path, links);
+    // NOTICE("chinit_dev %s %d %d 0%o\n", path, uid, gid, mode);
+    chown(path, uid, gid);
+    chmod(path, mode);
+}
+
 void DeviceHandler::MakeDevice(const std::string& path, bool block, int major, int minor,
                                const std::vector<std::string>& links) const {
     auto[mode, uid, gid] = GetDevicePermissions(path, links);
@@ -343,6 +352,10 @@

 void DeviceHandler::HandleDevice(const std::string& action, const std::string& devpath, bool block,
                                  int major, int minor, const std::vector<std::string>& links) const {
+    std::string temp = devpath.substr(0, 11);
+    if ((temp.compare("/dev/input/")) == 0) {
+        return;
+    }
     if (action == "add") {
         MakeDevice(devpath, block, major, minor, links);
         for (const auto& link : links) {
diff -Nur a/init/devices.h b/init/devices.h
--- a/init/devices.h      2020-10-19 09:33:17.000000000 +0800
+++ b/init/devices.h      2020-12-22 14:48:11.280527722 +0800
@@ -112,7 +112,7 @@

     std::vector<std::string> GetBlockDeviceSymlinks(const Uevent& uevent) const;
     void set_skip_restorecon(bool value) { skip_restorecon_ = value; }
-
+    void chinit_dev(const char *path);
   private:
     bool FindPlatformDevice(std::string path, std::string* platform_device_path) const;
     std::tuple<mode_t, uid_t, gid_t> GetDevicePermissions(
diff --git a/init/init.cpp b/init/init.cpp
index 4fe115e92..7d69dd221 100644
--- a/init/init.cpp
+++ b/init/init.cpp
@@ -179,7 +179,7 @@
         // but rather from a callback from the property service socket, in which case this hack can
         // go away.
         shutdown_command = value;
-        do_shutdown = true;
+        do_shutdown = false;
     }
 
     if (property_triggers_enabled) ActionManager::GetInstance().QueuePropertyChange(name, value);
@@ -336,10 +336,12 @@
 }
 
 static Result<Success> console_init_action(const BuiltinArguments& args) {
+#if 0
     std::string console = GetProperty("ro.boot.console", "");
     if (!console.empty()) {
         default_console = "/dev/" + console;
     }
+#endif
     return Success();
 }
 
@@ -381,7 +383,7 @@
         { "ro.boot.mode",       "ro.bootmode",   "unknown", },
         { "ro.boot.baseband",   "ro.baseband",   "unknown", },
         { "ro.boot.bootloader", "ro.bootloader", "unknown", },
-        { "ro.boot.hardware",   "ro.hardware",   "unknown", },
+        { "ro.boot.hardware",   "ro.hardware",   "goldfish", },
         { "ro.boot.revision",   "ro.revision",   "0", },
     };
     for (size_t i = 0; i < arraysize(prop_map); i++) {
@@ -573,18 +575,18 @@
         setenv("PATH", _PATH_DEFPATH, 1);
         // Get the basic filesystem setup we need put together in the initramdisk
         // on / and then we'll let the rc file figure out the rest.
-        mount("tmpfs", "/dev", "tmpfs", MS_NOSUID, "mode=0755");
+        // mount("tmpfs", "/dev", "tmpfs", MS_NOSUID, "mode=0755");
         mkdir("/dev/pts", 0755);
         mkdir("/dev/socket", 0755);
-        mount("devpts", "/dev/pts", "devpts", 0, NULL);
-        #define MAKE_STR(x) __STRING(x)
-        mount("proc", "/proc", "proc", 0, "hidepid=2,gid=" MAKE_STR(AID_READPROC));
+        // mount("devpts", "/dev/pts", "devpts", 0, NULL);
+        // #define MAKE_STR(x) __STRING(x)
+        // mount("proc", "/proc", "proc", 0, "hidepid=2,gid=" MAKE_STR(AID_READPROC));
         // Don't expose the raw commandline to unprivileged processes.
-        chmod("/proc/cmdline", 0440);
-        gid_t groups[] = { AID_READPROC };
-        setgroups(arraysize(groups), groups);
+        // chmod("/proc/cmdline", 0440);
+        // gid_t groups[] = { AID_READPROC };
+        // setgroups(arraysize(groups), groups);
         mount("sysfs", "/sys", "sysfs", 0, NULL);
-        mount("selinuxfs", "/sys/fs/selinux", "selinuxfs", 0, NULL);
+        // mount("selinuxfs", "/sys/fs/selinux", "selinuxfs", 0, NULL);
 
         mknod("/dev/kmsg", S_IFCHR | 0600, makedev(1, 11));
 
@@ -618,6 +620,7 @@
         // Enable seccomp if global boot option was passed (otherwise it is enabled in zygote).
         global_seccomp();
 
+#if 0
         // Set up SELinux, loading the SELinux policy.
         SelinuxSetupKernelLogging();
         SelinuxInitialize();
@@ -628,6 +631,7 @@
             PLOG(FATAL) << "restorecon failed of /init failed";
         }
 
+#endif
         setenv("INIT_SECOND_STAGE", "true", 1);
 
         static constexpr uint32_t kNanosecondsPerMillisecond = 1e6;
@@ -644,7 +648,7 @@
     }
 
     // At this point we're in the second stage of init.
-    InitKernelLogging(argv);
+    // InitKernelLogging(argv);
     LOG(INFO) << "init second stage started!";
 
     // Set up a session keyring that all processes will have access to. It
@@ -657,22 +661,24 @@
 
     property_init();
 
+#if 0
     // If arguments are passed both on the command line and in DT,
     // properties set in DT always have priority over the command-line ones.
     process_kernel_dt();
     process_kernel_cmdline();
+#endif
 
     // Propagate the kernel variables to internal variables
     // used by init as well as the current required properties.
     export_kernel_boot_props();
 
     // Make the time that init started available for bootstat to log.
-    property_set("ro.boottime.init", getenv("INIT_STARTED_AT"));
-    property_set("ro.boottime.init.selinux", getenv("INIT_SELINUX_TOOK"));
+    // property_set("ro.boottime.init", getenv("INIT_STARTED_AT"));//getenv("INIT_STARTED_AT") = null
+    // property_set("ro.boottime.init.selinux", getenv("INIT_SELINUX_TOOK"));
 
     // Set libavb version for Framework-only OTA match in Treble build.
-    const char* avb_version = getenv("INIT_AVB_VERSION");
-    if (avb_version) property_set("ro.boot.avb_version", avb_version);
+    // const char* avb_version = getenv("INIT_AVB_VERSION");
+    // if (avb_version) property_set("ro.boot.avb_version", avb_version);
 
     // Clean up our environment.
     unsetenv("INIT_SECOND_STAGE");
@@ -680,10 +686,12 @@
     unsetenv("INIT_SELINUX_TOOK");
     unsetenv("INIT_AVB_VERSION");
 
+#if 0
     // Now set up SELinux for second stage.
     SelinuxSetupKernelLogging();
     SelabelInitialize();
     SelinuxRestoreContext();
+#endif
 
     epoll_fd = epoll_create1(EPOLL_CLOEXEC);
     if (epoll_fd == -1) {
@@ -723,17 +731,19 @@
     am.QueueBuiltinAction(wait_for_coldboot_done_action, "wait_for_coldboot_done");
     // ... so that we can start queuing up actions that require stuff from /dev.
     am.QueueBuiltinAction(MixHwrngIntoLinuxRngAction, "MixHwrngIntoLinuxRng");
-    am.QueueBuiltinAction(SetMmapRndBitsAction, "SetMmapRndBits");
-    am.QueueBuiltinAction(SetKptrRestrictAction, "SetKptrRestrict");
+    // am.QueueBuiltinAction(SetMmapRndBitsAction, "SetMmapRndBits");
+    // am.QueueBuiltinAction(SetKptrRestrictAction, "SetKptrRestrict");
     am.QueueBuiltinAction(keychord_init_action, "keychord_init");
     am.QueueBuiltinAction(console_init_action, "console_init");
 
     // Trigger all the boot actions to get us started.
     am.QueueEventTrigger("init");
 
+#if 0
     // Repeat mix_hwrng_into_linux_rng in case /dev/hw_random or /dev/random
     // wasn't ready immediately after wait_for_coldboot_done
     am.QueueBuiltinAction(MixHwrngIntoLinuxRngAction, "MixHwrngIntoLinuxRng");
+#endif
 
     // Don't mount filesystems or start core system services in charger mode.
     std::string bootmode = GetProperty("ro.bootmode", "");
diff --git a/init/log.cpp b/init/log.cpp
index 6198fc25f..70af27c36 100644
--- a/init/log.cpp
+++ b/init/log.cpp
@@ -53,6 +53,7 @@ static void InitAborter(const char* abort_message) {
 }
 
 void InitKernelLogging(char* argv[]) {
+#if 0
     // Make stdin/stdout/stderr all point to /dev/null.
     int fd = open("/sys/fs/selinux/null", O_RDWR);
     if (fd == -1) {
@@ -65,6 +66,7 @@ void InitKernelLogging(char* argv[]) {
     dup2(fd, 1);
     dup2(fd, 2);
     if (fd > 2) close(fd);
+#endif
 
     android::base::InitLogging(argv, &android::base::KernelLogger, InitAborter);
 }
diff --git a/init/property_service.cpp b/init/property_service.cpp
index 4172ba754..c845e289a 100644
--- a/init/property_service.cpp
+++ b/init/property_service.cpp
@@ -471,9 +471,11 @@ uint32_t HandlePropertySet(const std::string& name, const std::string& value,
                   << process_log_string;
     }
 
+#if 0
     if (name == "selinux.restorecon_recursive") {
         return PropertySetAsync(name, value, RestoreconRecursiveAsync, error);
     }
+#endif
 
     return PropertySet(name, value, error);
 }
@@ -838,9 +840,11 @@ void CreateSerializedPropertyInfo() {
 }
 
 void start_property_service() {
+#if 0
     selinux_callback cb;
     cb.func_audit = SelinuxAuditCallback;
     selinux_set_callback(SELINUX_CB_AUDIT, cb);
+#endif
 
     property_set("ro.property_service.version", "2");
 
diff --git a/init/selinux.cpp b/init/selinux.cpp
index 0ba5c4ae3..276bfec93 100644
--- a/init/selinux.cpp
+++ b/init/selinux.cpp
@@ -89,10 +89,13 @@ EnforcingStatus StatusFromCmdline() {
 }
 
 bool IsEnforcing() {
+#if 0
     if (ALLOW_PERMISSIVE_SELINUX) {
         return StatusFromCmdline() == SELINUX_ENFORCING;
     }
     return true;
+#endif
+    return false; // permissive
 }
 
 // Forks, executes the provided program in the child, and waits for the completion in the parent.
@@ -457,6 +460,9 @@ void SelinuxSetupKernelLogging() {
 
 // This function checks whether the sepolicy supports vendor init.
 bool SelinuxHasVendorInit() {
+    if (true) {
+        return false;
+    }
     if (!IsSplitPolicyDevice()) {
         // If this device does not split sepolicy files, vendor_init will be available in the latest
         // monolithic sepolicy file.
diff --git a/init/service.cpp b/init/service.cpp
index 37d3a8807..14c32b5cf 100644
--- a/init/service.cpp
+++ b/init/service.cpp
@@ -66,6 +66,7 @@ using android::base::WriteStringToFile;
 namespace android {
 namespace init {
 
+#if 0
 static Result<std::string> ComputeContextFromExecutable(const std::string& service_path) {
     std::string computed_context;
 
@@ -101,6 +102,7 @@ static Result<std::string> ComputeContextFromExecutable(const std::string& servi
     }
     return computed_context;
 }
+#endif
 
 Result<Success> Service::SetUpMountNamespace() const {
     constexpr unsigned int kSafeFlags = MS_NODEV | MS_NOEXEC | MS_NOSUID;
@@ -824,6 +826,7 @@ Result<Success> Service::Start() {
     }
 
     std::string scon;
+#if 0
     if (!seclabel_.empty()) {
         scon = seclabel_;
     } else {
@@ -833,6 +836,7 @@ Result<Success> Service::Start() {
         }
         scon = *result;
     }
+#endif
 
     LOG(INFO) << "starting service '" << name_ << "'...";
 
@@ -846,6 +850,7 @@ Result<Success> Service::Start() {
     if (pid == 0) {
         umask(077);
 
+#if 0
         if (auto result = EnterNamespaces(); !result) {
             LOG(FATAL) << "Service '" << name_ << "' could not enter namespaces: " << result.error();
         }
@@ -865,14 +870,17 @@ Result<Success> Service::Start() {
                            << "' could not set up PID namespace: " << result.error();
             }
         }
+#endif
 
         for (const auto& [key, value] : environment_vars_) {
+            LOG(FATAL) << "key = " << key << " value = " << value;
             setenv(key.c_str(), value.c_str(), 1);
         }
 
         std::for_each(descriptors_.begin(), descriptors_.end(),
                       std::bind(&DescriptorInfo::CreateAndPublish, std::placeholders::_1, scon));
 
+#if 0
         // See if there were "writepid" instructions to write to files under /dev/cpuset/.
         auto cpuset_predicate = [](const std::string& path) {
             return StartsWith(path, "/dev/cpuset/");
@@ -919,6 +927,7 @@ Result<Success> Service::Start() {
         // As requested, set our gid, supplemental gids, uid, context, and
         // priority. Aborts on failure.
         SetProcessAttributes();
+#endif
 
         if (!ExpandArgsAndExecv(args_)) {
             PLOG(ERROR) << "cannot execve('" << args_[0] << "')";
diff --git a/init/subcontext.cpp b/init/subcontext.cpp
index fdb46415d..38be05ed0 100644
--- a/init/subcontext.cpp
+++ b/init/subcontext.cpp
@@ -214,7 +214,7 @@ int SubcontextMain(int argc, char** argv, const KeywordFunctionMap* function_map
     auto context = std::string(argv[2]);
     auto init_fd = std::atoi(argv[3]);
 
-    SelabelInitialize();
+    // SelabelInitialize();
 
     property_set = SubcontextPropertySet;
 
diff --git a/init/ueventd.cpp b/init/ueventd.cpp
index a284203ba..bd3547b5a 100644
--- a/init/ueventd.cpp
+++ b/init/ueventd.cpp
@@ -260,11 +260,18 @@

     LOG(INFO) << "ueventd started!";

-    SelinuxSetupKernelLogging();
-    SelabelInitialize();
+    // SelinuxSetupKernelLogging();
+    // SelabelInitialize();

     DeviceHandler device_handler = CreateDeviceHandler();
     UeventListener uevent_listener;
+
+    device_handler.chinit_dev("/dev/binder");
+    device_handler.chinit_dev("/dev/hwbinder");
+    device_handler.chinit_dev("/dev/vndbinder");
+    device_handler.chinit_dev("/dev/ashmem");
+    device_handler.chinit_dev("/dev/uinput");
+    device_handler.chinit_dev("/dev/dri/renderD128");

     if (access(COLDBOOT_DONE, F_OK) != 0) {
         ColdBoot cold_boot(uevent_listener, device_handler);
diff --git a/init/util.cpp b/init/util.cpp
index 4455b2eb1..d31be6cb9 100644
--- a/init/util.cpp
+++ b/init/util.cpp
@@ -87,12 +87,14 @@ Result<uid_t> DecodeUid(const std::string& name) {
  */
 int CreateSocket(const char* name, int type, bool passcred, mode_t perm, uid_t uid, gid_t gid,
                  const char* socketcon) {
+#if 0
     if (socketcon) {
         if (setsockcreatecon(socketcon) == -1) {
             PLOG(ERROR) << "setsockcreatecon(\"" << socketcon << "\") failed";
             return -1;
         }
     }
+#endif
 
     android::base::unique_fd fd(socket(PF_UNIX, type, 0));
     if (fd < 0) {
@@ -100,7 +102,7 @@ int CreateSocket(const char* name, int type, bool passcred, mode_t perm, uid_t u
         return -1;
     }
 
-    if (socketcon) setsockcreatecon(NULL);
+    // if (socketcon) setsockcreatecon(NULL);
 
     struct sockaddr_un addr;
     memset(&addr, 0 , sizeof(addr));
@@ -113,10 +115,12 @@ int CreateSocket(const char* name, int type, bool passcred, mode_t perm, uid_t u
         return -1;
     }
 
+#if 0
     std::string secontext;
     if (SelabelLookupFileContext(addr.sun_path, S_IFSOCK, &secontext) && !secontext.empty()) {
         setfscreatecon(secontext.c_str());
     }
+#endif
 
     if (passcred) {
         int on = 1;
@@ -129,9 +133,11 @@ int CreateSocket(const char* name, int type, bool passcred, mode_t perm, uid_t u
     int ret = bind(fd, (struct sockaddr *) &addr, sizeof (addr));
     int savederrno = errno;
 
+#if 0
     if (!secontext.empty()) {
         setfscreatecon(nullptr);
     }
+#endif
 
     if (ret) {
         errno = savederrno;
@@ -185,6 +191,7 @@ Result<std::string> ReadFile(const std::string& path) {
 }
 
 static int OpenFile(const std::string& path, int flags, mode_t mode) {
+#if 0
     std::string secontext;
     if (SelabelLookupFileContext(path, mode, &secontext) && !secontext.empty()) {
         setfscreatecon(secontext.c_str());
@@ -197,7 +204,9 @@ static int OpenFile(const std::string& path, int flags, mode_t mode) {
         setfscreatecon(nullptr);
         errno = save_errno;
     }
+#endif
 
+    int rc = open(path.c_str(), flags, mode);
     return rc;
 }
 
@@ -256,6 +265,7 @@ void import_kernel_cmdline(bool in_qemu,
 }
 
 bool make_dir(const std::string& path, mode_t mode) {
+#if 0
     std::string secontext;
     if (SelabelLookupFileContext(path, mode, &secontext) && !secontext.empty()) {
         setfscreatecon(secontext.c_str());
@@ -268,7 +278,9 @@ bool make_dir(const std::string& path, mode_t mode) {
         setfscreatecon(nullptr);
         errno = save_errno;
     }
+#endif
 
+    int rc = mkdir(path.c_str(), mode);
     return rc == 0;
 }
 
diff --git a/libcutils/android_reboot.cpp b/libcutils/android_reboot.cpp
index ce41cd320..33da075c1 100644
--- a/libcutils/android_reboot.cpp
+++ b/libcutils/android_reboot.cpp
@@ -24,6 +24,7 @@
 #define TAG "android_reboot"
 
 int android_reboot(int cmd, int /*flags*/, const char* arg) {
+#if 0
     int ret;
     const char* restart_cmd = NULL;
     char* prop_value;
@@ -50,4 +51,8 @@ int android_reboot(int cmd, int /*flags*/, const char* arg) {
     ret = property_set(ANDROID_RB_PROPERTY, prop_value);
     free(prop_value);
     return ret;
+#endif
+    (void) cmd;
+    (void)arg;
+    return 0;
 }
diff --git a/libprocessgroup/Android.bp b/libprocessgroup/Android.bp
index b0bc497ab..f166d0a95 100644
--- a/libprocessgroup/Android.bp
+++ b/libprocessgroup/Android.bp
@@ -7,5 +7,7 @@ cc_library {
     cflags: [
         "-Wall",
         "-Werror",
+	"-Wno-unused-parameter",
+	"-Wno-unused-function",
     ],
 }
diff --git a/libprocessgroup/processgroup.cpp b/libprocessgroup/processgroup.cpp
index 58295fadb..f1a1fb1ab 100644
--- a/libprocessgroup/processgroup.cpp
+++ b/libprocessgroup/processgroup.cpp
@@ -132,6 +132,7 @@ static void RemoveUidProcessGroups(const std::string& uid_path) {
 
 void removeAllProcessGroups()
 {
+#if 0
     LOG(VERBOSE) << "removeAllProcessGroups()";
     const auto& cgroup_root_path = GetCgroupRootPath();
     std::unique_ptr<DIR, decltype(&closedir)> root(opendir(cgroup_root_path.c_str()), closedir);
@@ -154,6 +155,7 @@ void removeAllProcessGroups()
             if (rmdir(path.c_str()) == -1) PLOG(WARNING) << "Failed to remove " << path;
         }
     }
+#endif
 }
 
 // Returns number of processes killed on success
@@ -272,11 +274,13 @@ static int KillProcessGroup(uid_t uid, int initialPid, int signal, int retries)
 }
 
 int killProcessGroup(uid_t uid, int initialPid, int signal) {
-    return KillProcessGroup(uid, initialPid, signal, 40 /*retries*/);
+    // return KillProcessGroup(uid, initialPid, signal, 40 /*retries*/);
+    return 0;
 }
 
 int killProcessGroupOnce(uid_t uid, int initialPid, int signal) {
-    return KillProcessGroup(uid, initialPid, signal, 0 /*retries*/);
+    // return KillProcessGroup(uid, initialPid, signal, 0 /*retries*/);
+    return 0;
 }
 
 static bool MkdirAndChown(const std::string& path, mode_t mode, uid_t uid, gid_t gid) {
@@ -296,6 +300,7 @@ static bool MkdirAndChown(const std::string& path, mode_t mode, uid_t uid, gid_t
 
 int createProcessGroup(uid_t uid, int initialPid)
 {
+#if 0
     auto uid_path = ConvertUidToPath(uid);
 
     if (!MkdirAndChown(uid_path, 0750, AID_SYSTEM, AID_SYSTEM)) {
@@ -319,6 +324,8 @@ int createProcessGroup(uid_t uid, int initialPid)
     }
 
     return ret;
+#endif
+    return 0;
 }
 
 static bool SetProcessGroupValue(uid_t uid, int pid, const std::string& file_name, int64_t value) {
@@ -337,13 +344,16 @@ static bool SetProcessGroupValue(uid_t uid, int pid, const std::string& file_nam
 }
 
 bool setProcessGroupSwappiness(uid_t uid, int pid, int swappiness) {
-    return SetProcessGroupValue(uid, pid, "/memory.swappiness", swappiness);
+    // return SetProcessGroupValue(uid, pid, "/memory.swappiness", swappiness);
+    return 0;
 }
 
 bool setProcessGroupSoftLimit(uid_t uid, int pid, int64_t soft_limit_in_bytes) {
-    return SetProcessGroupValue(uid, pid, "/memory.soft_limit_in_bytes", soft_limit_in_bytes);
+    // return SetProcessGroupValue(uid, pid, "/memory.soft_limit_in_bytes", soft_limit_in_bytes);
+    return 0;
 }
 
 bool setProcessGroupLimit(uid_t uid, int pid, int64_t limit_in_bytes) {
-    return SetProcessGroupValue(uid, pid, "/memory.limit_in_bytes", limit_in_bytes);
+    // return SetProcessGroupValue(uid, pid, "/memory.limit_in_bytes", limit_in_bytes);
+    return 0;
 }
diff --git a/libsuspend/Android.bp b/libsuspend/Android.bp
index b3e36c2bd..14cf0bfbe 100644
--- a/libsuspend/Android.bp
+++ b/libsuspend/Android.bp
@@ -21,5 +21,7 @@ cc_library {
     cflags: [
         "-Werror",
         // "-DLOG_NDEBUG=0",
+	"-Wno-unused-parameter",
+        "-Wno-unused-function",
     ],
 }
diff --git a/libsuspend/autosuspend.c b/libsuspend/autosuspend.c
index b87f59cd6..a8546f127 100644
--- a/libsuspend/autosuspend.c
+++ b/libsuspend/autosuspend.c
@@ -28,6 +28,7 @@ static struct autosuspend_ops* autosuspend_ops = NULL;
 static bool autosuspend_enabled;
 
 static int autosuspend_init(void) {
+#if 0
     if (autosuspend_ops != NULL) {
         return 0;
     }
@@ -39,10 +40,12 @@ static int autosuspend_init(void) {
     }
 
     ALOGV("autosuspend initialized");
+#endif
     return 0;
 }
 
 int autosuspend_enable(void) {
+#if 0
     int ret;
 
     ret = autosuspend_init();
@@ -62,10 +65,12 @@ int autosuspend_enable(void) {
     }
 
     autosuspend_enabled = true;
+#endif
     return 0;
 }
 
 int autosuspend_disable(void) {
+#if 0
     int ret;
 
     ret = autosuspend_init();
@@ -85,10 +90,12 @@ int autosuspend_disable(void) {
     }
 
     autosuspend_enabled = false;
+#endif
     return 0;
 }
 
 int autosuspend_force_suspend(int timeout_ms) {
+#if 0
     int ret;
 
     ret = autosuspend_init();
@@ -99,9 +106,13 @@ int autosuspend_force_suspend(int timeout_ms) {
     ALOGV("autosuspend_force_suspend");
 
     return autosuspend_ops->force_suspend(timeout_ms);
+#endif
+    (void) timeout_ms;
+    return 0;
 }
 
 void autosuspend_set_wakeup_callback(void (*func)(bool success)) {
+#if 0
     int ret;
 
     ret = autosuspend_init();
@@ -112,4 +123,5 @@ void autosuspend_set_wakeup_callback(void (*func)(bool success)) {
     ALOGV("set_wakeup_callback");
 
     autosuspend_ops->set_wakeup_callback(func);
+#endif
 }
diff --git a/logd/main.cpp b/logd/main.cpp
index 4af0d21f1..c0f7b1f28 100644
--- a/logd/main.cpp
+++ b/logd/main.cpp
@@ -90,6 +90,10 @@
 static int drop_privs(bool klogd, bool auditd) {
     // Tricky, if ro.build.type is "eng" then this is true because of the
     // side effect that ro.debuggable == 1 as well, else it is false.
+    (void) klogd;
+    (void) auditd;
+    return 0;
+#if 0
     bool eng =
         __android_logger_property_get_bool("ro.build.type", BOOL_DEFAULT_FALSE);
 
@@ -171,6 +175,7 @@ static int drop_privs(bool klogd, bool auditd) {
     }
 
     return 0;
+#endif
 }
 
 // Property helper
@@ -190,9 +195,9 @@ static bool check_flag(const char* prop, const char* flag) {
 
 static int fdDmesg = -1;
 void android::prdebug(const char* fmt, ...) {
-    if (fdDmesg < 0) {
-        return;
-    }
+    // if (fdDmesg < 0) {
+    //    return;
+    // }
 
     static const char message[] = {
         KMSG_PRIORITY(LOG_DEBUG), 'l', 'o', 'g', 'd', ':', ' '
@@ -211,7 +216,8 @@ void android::prdebug(const char* fmt, ...) {
             buffer[sizeof(buffer) - 2] = '\0';
             strlcat(buffer, "\n", sizeof(buffer));
         }
-        write(fdDmesg, buffer, strlen(buffer));
+        // write(fdDmesg, buffer, strlen(buffer));
+        printf("%s", buffer);
     }
 }
 
@@ -474,7 +480,7 @@ int main(int argc, char* argv[]) {
     bool auditd =
         __android_logger_property_get_bool("ro.logd.auditd", BOOL_DEFAULT_TRUE);
     if (drop_privs(klogd, auditd) != 0) {
-        return -1;
+        // return -1;
     }
 
     // Serves the purpose of managing the last logs times read on a
@@ -502,6 +508,7 @@ int main(int argc, char* argv[]) {
 
     LogReader* reader = new LogReader(logBuf);
     if (reader->startListener()) {
+        android::prdebug("Failed to reader->startListener(),exit");
         exit(1);
     }
 
diff --git a/qemu_pipe/qemu_pipe.cpp b/qemu_pipe/qemu_pipe.cpp
index beeccb07f..031049e44 100644
--- a/qemu_pipe/qemu_pipe.cpp
+++ b/qemu_pipe/qemu_pipe.cpp
@@ -21,6 +21,8 @@
 #include <string.h>
 #include <errno.h>
 #include <stdio.h>
+#include <sys/socket.h>
+#include <sys/un.h>
 
 #include <android-base/file.h>
 
@@ -41,7 +43,29 @@ int qemu_pipe_open(const char* pipeName) {
         return -1;
     }
 
-    int fd = TEMP_FAILURE_RETRY(open("/dev/qemu_pipe", O_RDWR));
+    int fd = -1;
+#if 0
+    fd = TEMP_FAILURE_RETRY(open("/dev/qemu_pipe", O_RDWR));
+#else
+    fd = socket(AF_LOCAL, SOCK_STREAM, 0);
+
+    struct sockaddr_un addr;
+    memset(&addr, 0, sizeof(addr));
+    addr.sun_family = AF_UNIX;
+    strncpy(addr.sun_path, "/dev/qemu_pipe", sizeof(addr.sun_path));
+
+    if (connect(fd, (struct sockaddr*) &addr, sizeof(addr)) < 0) {
+#if !defined(QEMU_PIPE_FROM_ADB)
+        close(fd);
+#else
+        // Adb renames 'close' to 'unix_close' and marks the original
+        // 'close' as not available.
+        unix_close(fd);
+#endif
+        fd = -1;
+    }
+#endif
+
     if (fd < 0) {
         QEMU_PIPE_DEBUG("%s: Could not open /dev/qemu_pipe: %s", __FUNCTION__,
                         strerror(errno));
diff --git a/rootdir/init.rc b/rootdir/init.rc
index b9464e7fd..faa77fbe2 100644
--- a/rootdir/init.rc
+++ b/rootdir/init.rc
@@ -8,7 +8,7 @@ import /init.environ.rc
 import /init.usb.rc
 import /init.${ro.hardware}.rc
 import /vendor/etc/init/hw/init.${ro.hardware}.rc
-import /init.usb.configfs.rc
+# import /init.usb.configfs.rc
 import /init.${ro.zygote}.rc
 
 on early-init
@@ -559,21 +559,21 @@ on post-fs-data
 # to start-zygote in device's init.rc to unblock zygote start.
 on zygote-start && property:ro.crypto.state=unencrypted
     # A/B update verifier that marks a successful boot.
-    exec_start update_verifier_nonencrypted
+    # exec_start update_verifier_nonencrypted
     start netd
     start zygote
     start zygote_secondary
 
 on zygote-start && property:ro.crypto.state=unsupported
     # A/B update verifier that marks a successful boot.
-    exec_start update_verifier_nonencrypted
+    # exec_start update_verifier_nonencrypted
     start netd
     start zygote
     start zygote_secondary
 
 on zygote-start && property:ro.crypto.state=encrypted && property:ro.crypto.type=file
     # A/B update verifier that marks a successful boot.
-    exec_start update_verifier_nonencrypted
+    # exec_start update_verifier_nonencrypted
     start netd
     start zygote
     start zygote_secondary
@@ -677,9 +677,10 @@ on boot
 
     class_start core
 
-on nonencrypted
+# on nonencrypted
     class_start main
     class_start late_start
+    start cpuDetect
 
 on property:sys.init_log_level=*
     loglevel ${sys.init_log_level}
@@ -762,8 +763,13 @@ on property:ro.debuggable=1
     chmod 0773 /data/misc/trace
     # Give reads to anyone for the window trace folder on debug builds.
     chmod 0775 /data/misc/wmtrace
-    start console
+    # start console
 
 service flash_recovery /system/bin/install-recovery.sh
     class main
     oneshot
+
+service cpuDetect /system/bin/cpuDetect
+    class core
+    user root
+    oneshot
diff --git a/rootdir/init.zygote32.rc b/rootdir/init.zygote32.rc
index ac87979ec..4dc76aebc 100644
--- a/rootdir/init.zygote32.rc
+++ b/rootdir/init.zygote32.rc
@@ -4,11 +4,11 @@ service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-sys
     user root
     group root readproc reserved_disk
     socket zygote stream 660 root system
-    onrestart write /sys/android_power/request_state wake
-    onrestart write /sys/power/state on
+    # onrestart write /sys/android_power/request_state wake
+    # onrestart write /sys/power/state on
     onrestart restart audioserver
     onrestart restart cameraserver
     onrestart restart media
     onrestart restart netd
     onrestart restart wificond
-    writepid /dev/cpuset/foreground/tasks
+    # writepid /dev/cpuset/foreground/tasks
diff --git a/rootdir/init.zygote32_64.rc b/rootdir/init.zygote32_64.rc
index a535846de..26969e7ac 100644
--- a/rootdir/init.zygote32_64.rc
+++ b/rootdir/init.zygote32_64.rc
@@ -4,14 +4,14 @@ service zygote /system/bin/app_process32 -Xzygote /system/bin --zygote --start-s
     user root
     group root readproc reserved_disk
     socket zygote stream 660 root system
-    onrestart write /sys/android_power/request_state wake
-    onrestart write /sys/power/state on
+    # onrestart write /sys/android_power/request_state wake
+    # onrestart write /sys/power/state on
     onrestart restart audioserver
     onrestart restart cameraserver
     onrestart restart media
     onrestart restart netd
     onrestart restart wificond
-    writepid /dev/cpuset/foreground/tasks
+    # writepid /dev/cpuset/foreground/tasks
 
 service zygote_secondary /system/bin/app_process64 -Xzygote /system/bin --zygote --socket-name=zygote_secondary
     class main
@@ -20,4 +20,4 @@ service zygote_secondary /system/bin/app_process64 -Xzygote /system/bin --zygote
     group root readproc reserved_disk
     socket zygote_secondary stream 660 root system
     onrestart restart zygote
-    writepid /dev/cpuset/foreground/tasks
+    # writepid /dev/cpuset/foreground/tasks
diff --git a/rootdir/init.zygote64.rc b/rootdir/init.zygote64.rc
index 6fc810bfa..76b1bb362 100644
--- a/rootdir/init.zygote64.rc
+++ b/rootdir/init.zygote64.rc
@@ -4,11 +4,11 @@ service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-s
     user root
     group root readproc reserved_disk
     socket zygote stream 660 root system
-    onrestart write /sys/android_power/request_state wake
-    onrestart write /sys/power/state on
+    # onrestart write /sys/android_power/request_state wake
+    # onrestart write /sys/power/state on
     onrestart restart audioserver
     onrestart restart cameraserver
     onrestart restart media
     onrestart restart netd
     onrestart restart wificond
-    writepid /dev/cpuset/foreground/tasks
+    # writepid /dev/cpuset/foreground/tasks
diff --git a/rootdir/init.zygote64_32.rc b/rootdir/init.zygote64_32.rc
index 7ddd52ee5..53c024a87 100644
--- a/rootdir/init.zygote64_32.rc
+++ b/rootdir/init.zygote64_32.rc
@@ -4,14 +4,14 @@ service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-s
     user root
     group root readproc reserved_disk
     socket zygote stream 660 root system
-    onrestart write /sys/android_power/request_state wake
-    onrestart write /sys/power/state on
+    # onrestart write /sys/android_power/request_state wake
+    # onrestart write /sys/power/state on
     onrestart restart audioserver
     onrestart restart cameraserver
     onrestart restart media
     onrestart restart netd
     onrestart restart wificond
-    writepid /dev/cpuset/foreground/tasks
+    # writepid /dev/cpuset/foreground/tasks
 
 service zygote_secondary /system/bin/app_process32 -Xzygote /system/bin --zygote --socket-name=zygote_secondary --enable-lazy-preload
     class main
@@ -20,4 +20,4 @@ service zygote_secondary /system/bin/app_process32 -Xzygote /system/bin --zygote
     group root readproc reserved_disk
     socket zygote_secondary stream 660 root system
     onrestart restart zygote
-    writepid /dev/cpuset/foreground/tasks
+    # writepid /dev/cpuset/foreground/tasks
diff --git a/sdcard/Android.bp b/sdcard/Android.bp
index c096587ba..81c7866ab 100644
--- a/sdcard/Android.bp
+++ b/sdcard/Android.bp
@@ -4,14 +4,14 @@ cc_binary {
     cflags: [
         "-Wall",
         "-Wno-unused-parameter",
+	"-Wno-unused-function",
         "-Werror",
     ],
     shared_libs: [
         "libbase",
         "libcutils",
         "libminijail",
+        "liblog",
+        "libpackagelistparser",
     ],
-    sanitize: {
-        misc_undefined: ["integer"],
-    },
 }
diff --git a/sdcard/sdcard.cpp b/sdcard/sdcard.cpp
index dc36596b1..bcc7e46d1 100644
--- a/sdcard/sdcard.cpp
+++ b/sdcard/sdcard.cpp
@@ -14,18 +14,27 @@
 
 #define LOG_TAG "sdcard"
 
+#include <ctype.h>
 #include <dirent.h>
 #include <errno.h>
 #include <fcntl.h>
+#include <inttypes.h>
+#include <limits.h>
 #include <linux/fuse.h>
 #include <pthread.h>
+#include <stdbool.h>
+#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <sys/inotify.h>
 #include <sys/mount.h>
+#include <sys/param.h>
 #include <sys/resource.h>
 #include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/time.h>
 #include <sys/types.h>
+#include <sys/uio.h>
 #include <unistd.h>
 
 #include <android-base/file.h>
@@ -35,268 +44,2002 @@
 #include <android-base/strings.h>
 
 #include <cutils/fs.h>
+#include <cutils/hashmap.h>
+#include <cutils/log.h>
 #include <cutils/multiuser.h>
 #include <cutils/properties.h>
+#include <packagelistparser/packagelistparser.h>
 
 #include <libminijail.h>
 #include <scoped_minijail.h>
 
 #include <private/android_filesystem_config.h>
 
+/* FUSE_CANONICAL_PATH is not currently upstreamed */
+#define FUSE_CANONICAL_PATH 2016
+
 #define PROP_SDCARDFS_DEVICE "ro.sys.sdcardfs"
 #define PROP_SDCARDFS_USER "persist.sys.sdcardfs"
 
-static bool supports_esdfs(void) {
-    std::string filesystems;
-    if (!android::base::ReadFileToString("/proc/filesystems", &filesystems)) {
-        PLOG(ERROR) << "Could not read /proc/filesystems";
-        return false;
-    }
-    for (const auto& fs : android::base::Split(filesystems, "\n")) {
-        if (fs.find("esdfs") != std::string::npos) return true;
-    }
-    return false;
-}
+#define FUSE_UNKNOWN_INO 0xffffffff
 
-static bool should_use_sdcardfs(void) {
-    char property[PROPERTY_VALUE_MAX];
-
-    // Allow user to have a strong opinion about state
-    property_get(PROP_SDCARDFS_USER, property, "");
-    if (!strcmp(property, "force_on")) {
-        LOG(WARNING) << "User explicitly enabled sdcardfs";
-        return true;
-    } else if (!strcmp(property, "force_off")) {
-        LOG(WARNING) << "User explicitly disabled sdcardfs";
-        return !supports_esdfs();
-    }
-
-    // Fall back to device opinion about state
-    if (property_get_bool(PROP_SDCARDFS_DEVICE, true)) {
-        LOG(WARNING) << "Device explicitly enabled sdcardfs";
-        return true;
-    } else {
-        LOG(WARNING) << "Device explicitly disabled sdcardfs";
-        return !supports_esdfs();
-    }
-}
-
-// NOTE: This is a vestigial program that simply exists to mount the in-kernel
-// sdcardfs filesystem.  The older FUSE-based design that used to live here has
-// been completely removed to avoid confusion.
-
-/* Supplementary groups to execute with. */
+/* Maximum number of bytes to write in one request. */
+#define MAX_WRITE (256 * 1024)
+
+/* Maximum number of bytes to read in one request. */
+#define MAX_READ (128 * 1024)
+
+/* Largest possible request.
+ * The request size is bounded by the maximum size of a FUSE_WRITE request because it has
+ * the largest possible data payload. */
+#define MAX_REQUEST_SIZE (sizeof(struct fuse_in_header) + sizeof(struct fuse_write_in) + MAX_WRITE)
+
+ /* Pseudo-error constant used to indicate that no fuse status is needed
+  * or that a reply has already been written. */
+#define NO_STATUS 1
+
+  /* Supplementary groups to execute with */
 static const gid_t kGroups[1] = { AID_PACKAGE_INFO };
 
-static void drop_privs(uid_t uid, gid_t gid) {
-    ScopedMinijail j(minijail_new());
-    minijail_set_supplementary_gids(j.get(), arraysize(kGroups), kGroups);
-    minijail_change_gid(j.get(), gid);
-    minijail_change_uid(j.get(), uid);
-    /* minijail_enter() will abort if priv-dropping fails. */
-    minijail_enter(j.get());
-}
-
-static bool sdcardfs_setup(const std::string& source_path, const std::string& dest_path,
-                           uid_t fsuid, gid_t fsgid, bool multi_user, userid_t userid, gid_t gid,
-                           mode_t mask, bool derive_gid, bool default_normal, bool use_esdfs) {
-    // Try several attempts, each time with one less option, to gracefully
-    // handle older kernels that aren't updated yet.
-    for (int i = 0; i < 4; i++) {
-        std::string new_opts;
-        if (multi_user && i < 3) new_opts += "multiuser,";
-        if (derive_gid && i < 2) new_opts += "derive_gid,";
-        if (default_normal && i < 1) new_opts += "default_normal,";
-
-        auto opts = android::base::StringPrintf("fsuid=%d,fsgid=%d,%smask=%d,userid=%d,gid=%d",
-                                                fsuid, fsgid, new_opts.c_str(), mask, userid, gid);
-        if (mount(source_path.c_str(), dest_path.c_str(), use_esdfs ? "esdfs" : "sdcardfs",
-                  MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_NOATIME, opts.c_str()) == -1) {
-            PLOG(WARNING) << "Failed to mount sdcardfs with options " << opts;
-        } else {
-            return true;
-        }
-    }
-
-    return false;
-}
-
-static bool sdcardfs_setup_bind_remount(const std::string& source_path, const std::string& dest_path,
-                                        gid_t gid, mode_t mask) {
-    std::string opts = android::base::StringPrintf("mask=%d,gid=%d", mask, gid);
-
-    if (mount(source_path.c_str(), dest_path.c_str(), nullptr,
-            MS_BIND, nullptr) != 0) {
-        PLOG(ERROR) << "failed to bind mount sdcardfs filesystem";
-        return false;
-    }
-
-    if (mount(source_path.c_str(), dest_path.c_str(), "none",
-            MS_REMOUNT | MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_NOATIME, opts.c_str()) != 0) {
-        PLOG(ERROR) << "failed to mount sdcardfs filesystem";
-        if (umount2(dest_path.c_str(), MNT_DETACH))
-            PLOG(WARNING) << "Failed to unmount bind";
-        return false;
-    }
-
-    return true;
-}
-
-static bool sdcardfs_setup_secondary(const std::string& default_path, const std::string& source_path,
-                                     const std::string& dest_path, uid_t fsuid, gid_t fsgid,
-                                     bool multi_user, userid_t userid, gid_t gid, mode_t mask,
-                                     bool derive_gid, bool default_normal, bool use_esdfs) {
-    if (use_esdfs) {
-        return sdcardfs_setup(source_path, dest_path, fsuid, fsgid, multi_user, userid, gid, mask,
-                              derive_gid, default_normal, use_esdfs);
-    } else {
-        return sdcardfs_setup_bind_remount(default_path, dest_path, gid, mask);
-    }
-}
-
-static void run_sdcardfs(const std::string& source_path, const std::string& label, uid_t uid,
-                         gid_t gid, userid_t userid, bool multi_user, bool full_write,
-                         bool derive_gid, bool default_normal, bool use_esdfs) {
-    std::string dest_path_default = "/mnt/runtime/default/" + label;
-    std::string dest_path_read = "/mnt/runtime/read/" + label;
-    std::string dest_path_write = "/mnt/runtime/write/" + label;
-
-    umask(0);
-    if (multi_user) {
-        // Multi-user storage is fully isolated per user, so "other"
-        // permissions are completely masked off.
-        if (!sdcardfs_setup(source_path, dest_path_default, uid, gid, multi_user, userid,
-                            AID_SDCARD_RW, 0006, derive_gid, default_normal, use_esdfs) ||
-            !sdcardfs_setup_secondary(dest_path_default, source_path, dest_path_read, uid, gid,
-                                      multi_user, userid, AID_EVERYBODY, 0027, derive_gid,
-                                      default_normal, use_esdfs) ||
-            !sdcardfs_setup_secondary(dest_path_default, source_path, dest_path_write, uid, gid,
-                                      multi_user, userid, AID_EVERYBODY, full_write ? 0007 : 0027,
-                                      derive_gid, default_normal, use_esdfs)) {
-            LOG(FATAL) << "failed to sdcardfs_setup";
-        }
-    } else {
-        // Physical storage is readable by all users on device, but
-        // the Android directories are masked off to a single user
-        // deep inside attr_from_stat().
-        if (!sdcardfs_setup(source_path, dest_path_default, uid, gid, multi_user, userid,
-                            AID_SDCARD_RW, 0006, derive_gid, default_normal, use_esdfs) ||
-            !sdcardfs_setup_secondary(dest_path_default, source_path, dest_path_read, uid, gid,
-                                      multi_user, userid, AID_EVERYBODY, full_write ? 0027 : 0022,
-                                      derive_gid, default_normal, use_esdfs) ||
-            !sdcardfs_setup_secondary(dest_path_default, source_path, dest_path_write, uid, gid,
-                                      multi_user, userid, AID_EVERYBODY, full_write ? 0007 : 0022,
-                                      derive_gid, default_normal, use_esdfs)) {
-            LOG(FATAL) << "failed to sdcardfs_setup";
-        }
-    }
-
-    // Will abort if priv-dropping fails.
-    drop_privs(uid, gid);
-
-    if (multi_user) {
-        std::string obb_path = source_path + "/obb";
-        fs_prepare_dir(obb_path.c_str(), 0775, uid, gid);
-    }
-
-    exit(0);
+/* Permission mode for a specific node. Controls how file permissions
+ * are derived for children nodes. */
+typedef enum {
+	/* Nothing special; this node should just inherit from its parent. */
+	PERM_INHERIT,
+	/* This node is one level above a normal root; used for legacy layouts
+	 * which use the first level to represent user_id. */
+	PERM_PRE_ROOT,
+	/* This node is "/" */
+	PERM_ROOT,
+	/* This node is "/Android" */
+	PERM_ANDROID,
+	/* This node is "/Android/data" */
+	PERM_ANDROID_DATA,
+	/* This node is "/Android/obb" */
+	PERM_ANDROID_OBB,
+	/* This node is "/Android/media" */
+	PERM_ANDROID_MEDIA,
+} perm_t;
+
+struct handle {
+	int fd;
+};
+
+struct dirhandle {
+	DIR *d;
+};
+
+struct node {
+	__u32 refcount;
+	__u64 nid;
+	__u64 gen;
+	/*
+	 * The inode number for this FUSE node. Note that this isn't stable across
+	 * multiple invocations of the FUSE daemon.
+	 */
+	__u32 ino;
+
+	/* State derived based on current position in hierarchy. */
+	perm_t perm;
+	userid_t userid;
+	uid_t uid;
+	bool under_android;
+
+	struct node *next;          /* per-dir sibling list */
+	struct node *child;         /* first contained file by this dir */
+	struct node *parent;        /* containing directory */
+
+	size_t namelen;
+	char *name;
+	/* If non-null, this is the real name of the file in the underlying storage.
+	 * This may differ from the field "name" only by case.
+	 * strlen(actual_name) will always equal strlen(name), so it is safe to use
+	 * namelen for both fields.
+	 */
+	char *actual_name;
+
+	/* If non-null, an exact underlying path that should be grafted into this
+	 * position. Used to support things like OBB. */
+	char* graft_path;
+	size_t graft_pathlen;
+
+	bool deleted;
+};
+
+static int str_hash(void *key) {
+	return hashmapHash(key, strlen((char *)key));
+}
+
+/** Test if two string keys are equal ignoring case */
+static bool str_icase_equals(void *keyA, void *keyB) {
+	return strcasecmp((char *)keyA, (char *)keyB) == 0;
+}
+
+/* Global data for all FUSE mounts */
+struct fuse_global {
+	pthread_mutex_t lock;
+
+	uid_t uid;
+	gid_t gid;
+	bool multi_user;
+
+	char source_path[PATH_MAX];
+	char obb_path[PATH_MAX];
+
+	Hashmap* package_to_appid;
+
+	__u64 next_generation;
+	struct node root;
+
+	/* Used to allocate unique inode numbers for fuse nodes. We use
+	 * a simple counter based scheme where inode numbers from deleted
+	 * nodes aren't reused. Note that inode allocations are not stable
+	 * across multiple invocation of the sdcard daemon, but that shouldn't
+	 * be a huge problem in practice.
+	 *
+	 * Note that we restrict inodes to 32 bit unsigned integers to prevent
+	 * truncation on 32 bit processes when unsigned long long stat.st_ino is
+	 * assigned to an unsigned long ino_t type in an LP32 process.
+	 *
+	 * Also note that fuse_attr and fuse_dirent inode values are 64 bits wide
+	 * on both LP32 and LP64, but the fuse kernel code doesn't squash 64 bit
+	 * inode numbers into 32 bit values on 64 bit kernels (see fuse_squash_ino
+	 * in fs/fuse/inode.c).
+	 *
+	 * Accesses must be guarded by |lock|.
+	 */
+	__u32 inode_ctr;
+
+	struct fuse* fuse_default;
+	struct fuse* fuse_read;
+	struct fuse* fuse_write;
+};
+
+/* Single FUSE mount */
+struct fuse {
+	struct fuse_global* global;
+
+	char dest_path[PATH_MAX];
+
+	int fd;
+
+	gid_t gid;
+	mode_t mask;
+};
+
+/* Private data used by a single FUSE handler */
+struct fuse_handler {
+	struct fuse* fuse;
+	int token;
+
+	/* To save memory, we never use the contents of the request buffer and the read
+	 * buffer at the same time.  This allows us to share the underlying storage. */
+	union {
+		__u8 request_buffer[MAX_REQUEST_SIZE];
+		__u8 read_buffer[MAX_READ + PAGE_SIZE];
+	};
+};
+
+static inline void *id_to_ptr(__u64 nid)
+{
+	return (void *)(uintptr_t)nid;
+}
+
+static inline __u64 ptr_to_id(void *ptr)
+{
+	return (__u64)(uintptr_t)ptr;
+}
+
+static void acquire_node_locked(struct node* node)
+{
+	node->refcount++;
+}
+
+static void remove_node_from_parent_locked(struct node* node);
+
+static void release_node_locked(struct node* node)
+{
+	if (node->refcount > 0) {
+		node->refcount--;
+		if (!node->refcount) {
+			remove_node_from_parent_locked(node);
+
+			memset(node->name, 0xef, node->namelen);
+			free(node->name);
+			free(node->actual_name);
+			memset(node, 0xfc, sizeof(*node));
+			free(node);
+		}
+	}
+}
+
+static void add_node_to_parent_locked(struct node *node, struct node *parent) {
+	node->parent = parent;
+	node->next = parent->child;
+	parent->child = node;
+	acquire_node_locked(parent);
+}
+
+static void remove_node_from_parent_locked(struct node* node)
+{
+	if (node->parent) {
+		if (node->parent->child == node) {
+			node->parent->child = node->parent->child->next;
+		}
+		else {
+			struct node *node2;
+			node2 = node->parent->child;
+			while (node2->next != node)
+				node2 = node2->next;
+			node2->next = node->next;
+		}
+		release_node_locked(node->parent);
+		node->parent = NULL;
+		node->next = NULL;
+	}
+}
+
+/* Gets the absolute path to a node into the provided buffer.
+ *
+ * Populates 'buf' with the path and returns the length of the path on success,
+ * or returns -1 if the path is too long for the provided buffer.
+ */
+static ssize_t get_node_path_locked(struct node* node, char* buf, size_t bufsize) {
+	const char* name;
+	size_t namelen;
+	if (node->graft_path) {
+		name = node->graft_path;
+		namelen = node->graft_pathlen;
+	}
+	else if (node->actual_name) {
+		name = node->actual_name;
+		namelen = node->namelen;
+	}
+	else {
+		name = node->name;
+		namelen = node->namelen;
+	}
+
+	if (bufsize < namelen + 1) {
+		return -1;
+	}
+
+	ssize_t pathlen = 0;
+	if (node->parent && node->graft_path == NULL) {
+		pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 1);
+		if (pathlen < 0) {
+			return -1;
+		}
+		buf[pathlen++] = '/';
+	}
+
+	memcpy(buf + pathlen, name, namelen + 1); /* include trailing \0 */
+	return pathlen + namelen;
+}
+
+/* Finds the absolute path of a file within a given directory.
+ * Performs a case-insensitive search for the file and sets the buffer to the path
+ * of the first matching file.  If 'search' is zero or if no match is found, sets
+ * the buffer to the path that the file would have, assuming the name were case-sensitive.
+ *
+ * Populates 'buf' with the path and returns the actual name (within 'buf') on success,
+ * or returns NULL if the path is too long for the provided buffer.
+ */
+static char* find_file_within(const char* path, const char* name,
+	char* buf, size_t bufsize, int search)
+{
+	size_t pathlen = strlen(path);
+	size_t namelen = strlen(name);
+	size_t childlen = pathlen + namelen + 1;
+	char* actual;
+
+	if (bufsize <= childlen) {
+		return NULL;
+	}
+
+	memcpy(buf, path, pathlen);
+	buf[pathlen] = '/';
+	actual = buf + pathlen + 1;
+	memcpy(actual, name, namelen + 1);
+
+	if (search && access(buf, F_OK)) {
+		struct dirent* entry;
+		DIR* dir = opendir(path);
+		if (!dir) {
+			return actual;
+		}
+		while ((entry = readdir(dir))) {
+			if (!strcasecmp(entry->d_name, name)) {
+				/* we have a match - replace the name, don't need to copy the null again */
+				memcpy(actual, entry->d_name, namelen);
+				break;
+			}
+		}
+		closedir(dir);
+	}
+	return actual;
+}
+
+static void attr_from_stat(struct fuse* fuse, struct fuse_attr *attr,
+	const struct stat *s, const struct node* node) {
+	attr->ino = node->ino;
+	attr->size = s->st_size;
+	attr->blocks = s->st_blocks;
+	attr->atime = s->st_atim.tv_sec;
+	attr->mtime = s->st_mtim.tv_sec;
+	attr->ctime = s->st_ctim.tv_sec;
+	attr->atimensec = s->st_atim.tv_nsec;
+	attr->mtimensec = s->st_mtim.tv_nsec;
+	attr->ctimensec = s->st_ctim.tv_nsec;
+	attr->mode = s->st_mode;
+	attr->nlink = s->st_nlink;
+
+	attr->uid = node->uid;
+
+	if (fuse->gid == AID_SDCARD_RW) {
+		/* As an optimization, certain trusted system components only run
+		 * as owner but operate across all users. Since we're now handing
+		 * out the sdcard_rw GID only to trusted apps, we're okay relaxing
+		 * the user boundary enforcement for the default view. The UIDs
+		 * assigned to app directories are still multiuser aware. */
+		attr->gid = AID_SDCARD_RW;
+	}
+	else {
+		attr->gid = multiuser_get_uid(node->userid, fuse->gid);
+	}
+
+	int visible_mode = 0775 & ~fuse->mask;
+	if (node->perm == PERM_PRE_ROOT) {
+		/* Top of multi-user view should always be visible to ensure
+		 * secondary users can traverse inside. */
+		visible_mode = 0711;
+	}
+	else if (node->under_android) {
+		/* Block "other" access to Android directories, since only apps
+		 * belonging to a specific user should be in there; we still
+		 * leave +x open for the default view. */
+		if (fuse->gid == AID_SDCARD_RW) {
+			visible_mode = visible_mode & ~0006;
+		}
+		else {
+			visible_mode = visible_mode & ~0007;
+		}
+	}
+	int owner_mode = s->st_mode & 0700;
+	int filtered_mode = visible_mode & (owner_mode | (owner_mode >> 3) | (owner_mode >> 6));
+	attr->mode = (attr->mode & S_IFMT) | filtered_mode;
+}
+
+static int touch(char* path, mode_t mode) {
+	int fd = open(path, O_RDWR | O_CREAT | O_EXCL | O_NOFOLLOW, mode);
+	if (fd == -1) {
+		if (errno == EEXIST) {
+			return 0;
+		}
+		else {
+			return -1;
+		}
+	}
+	close(fd);
+	return 0;
+}
+
+static void derive_permissions_locked(struct fuse* fuse, struct node *parent,
+	struct node *node) {
+	appid_t appid;
+
+	/* By default, each node inherits from its parent */
+	node->perm = PERM_INHERIT;
+	node->userid = parent->userid;
+	node->uid = parent->uid;
+	node->under_android = parent->under_android;
+
+	/* Derive custom permissions based on parent and current node */
+	switch (parent->perm) {
+	case PERM_INHERIT:
+		/* Already inherited above */
+		break;
+	case PERM_PRE_ROOT:
+		/* Legacy internal layout places users at top level */
+		node->perm = PERM_ROOT;
+		node->userid = strtoul(node->name, NULL, 10);
+		break;
+	case PERM_ROOT:
+		/* Assume masked off by default. */
+		if (!strcasecmp(node->name, "Android")) {
+			/* App-specific directories inside; let anyone traverse */
+			node->perm = PERM_ANDROID;
+			node->under_android = true;
+		}
+		break;
+	case PERM_ANDROID:
+		if (!strcasecmp(node->name, "data")) {
+			/* App-specific directories inside; let anyone traverse */
+			node->perm = PERM_ANDROID_DATA;
+		}
+		else if (!strcasecmp(node->name, "obb")) {
+			/* App-specific directories inside; let anyone traverse */
+			node->perm = PERM_ANDROID_OBB;
+			/* Single OBB directory is always shared */
+			node->graft_path = fuse->global->obb_path;
+			node->graft_pathlen = strlen(fuse->global->obb_path);
+		}
+		else if (!strcasecmp(node->name, "media")) {
+			/* App-specific directories inside; let anyone traverse */
+			node->perm = PERM_ANDROID_MEDIA;
+		}
+		break;
+	case PERM_ANDROID_DATA:
+	case PERM_ANDROID_OBB:
+	case PERM_ANDROID_MEDIA:
+		appid = (appid_t)(uintptr_t)hashmapGet(fuse->global->package_to_appid, node->name);
+		if (appid != 0) {
+			node->uid = multiuser_get_uid(parent->userid, appid);
+		}
+		break;
+	}
+}
+
+static void derive_permissions_recursive_locked(struct fuse* fuse, struct node *parent) {
+	struct node *node;
+	for (node = parent->child; node; node = node->next) {
+		derive_permissions_locked(fuse, parent, node);
+		if (node->child) {
+			derive_permissions_recursive_locked(fuse, node);
+		}
+	}
+}
+
+/* Kernel has already enforced everything we returned through
+ * derive_permissions_locked(), so this is used to lock down access
+ * even further, such as enforcing that apps hold sdcard_rw. */
+static bool check_caller_access_to_name(struct fuse* fuse,
+	const struct fuse_in_header *hdr, const struct node* parent_node,
+	const char* name, int mode) {
+	/* Always block security-sensitive files at root */
+	if (parent_node && parent_node->perm == PERM_ROOT) {
+		if (!strcasecmp(name, "autorun.inf")
+			|| !strcasecmp(name, ".android_secure")
+			|| !strcasecmp(name, "android_secure")) {
+			return false;
+		}
+	}
+
+	/* Root always has access; access for any other UIDs should always
+	 * be controlled through packages.list. */
+	if (hdr->uid == 0) {
+		return true;
+	}
+
+	/* No extra permissions to enforce */
+	return true;
+}
+
+static bool check_caller_access_to_node(struct fuse* fuse,
+	const struct fuse_in_header *hdr, const struct node* node, int mode) {
+	return check_caller_access_to_name(fuse, hdr, node->parent, node->name, mode);
+}
+
+struct node *create_node_locked(struct fuse* fuse,
+	struct node *parent, const char *name, const char* actual_name)
+{
+	struct node *node;
+	size_t namelen = strlen(name);
+
+	// Detect overflows in the inode counter. "4 billion nodes should be enough
+	// for everybody".
+	if (fuse->global->inode_ctr == 0) {
+		// ERROR("No more inode numbers available");
+		return NULL;
+	}
+
+	node = (struct node *)calloc(1, sizeof(struct node));
+	if (!node) {
+		return NULL;
+	}
+	node->name = (char *)malloc(namelen + 1);
+	if (!node->name) {
+		free(node);
+		return NULL;
+	}
+	memcpy(node->name, name, namelen + 1);
+	if (strcmp(name, actual_name)) {
+		node->actual_name = (char *)malloc(namelen + 1);
+		if (!node->actual_name) {
+			free(node->name);
+			free(node);
+			return NULL;
+		}
+		memcpy(node->actual_name, actual_name, namelen + 1);
+	}
+	node->namelen = namelen;
+	node->nid = ptr_to_id(node);
+	node->ino = fuse->global->inode_ctr++;
+	node->gen = fuse->global->next_generation++;
+
+	node->deleted = false;
+
+	derive_permissions_locked(fuse, parent, node);
+	acquire_node_locked(node);
+	add_node_to_parent_locked(node, parent);
+	return node;
+}
+
+static int rename_node_locked(struct node *node, const char *name,
+	const char* actual_name)
+{
+	size_t namelen = strlen(name);
+	int need_actual_name = strcmp(name, actual_name);
+
+	/* make the storage bigger without actually changing the name
+	 * in case an error occurs part way */
+	if (namelen > node->namelen) {
+		char* new_name = (char *)realloc(node->name, namelen + 1);
+		if (!new_name) {
+			return -ENOMEM;
+		}
+		node->name = new_name;
+		if (need_actual_name && node->actual_name) {
+			char* new_actual_name = (char *)realloc(node->actual_name, namelen + 1);
+			if (!new_actual_name) {
+				return -ENOMEM;
+			}
+			node->actual_name = new_actual_name;
+		}
+	}
+
+	/* update the name, taking care to allocate storage before overwriting the old name */
+	if (need_actual_name) {
+		if (!node->actual_name) {
+			node->actual_name = (char *)malloc(namelen + 1);
+			if (!node->actual_name) {
+				return -ENOMEM;
+			}
+		}
+		memcpy(node->actual_name, actual_name, namelen + 1);
+	}
+	else {
+		free(node->actual_name);
+		node->actual_name = NULL;
+	}
+	memcpy(node->name, name, namelen + 1);
+	node->namelen = namelen;
+	return 0;
+}
+
+static struct node *lookup_node_by_id_locked(struct fuse *fuse, __u64 nid)
+{
+	if (nid == FUSE_ROOT_ID) {
+		return &fuse->global->root;
+	}
+	else {
+		return (struct node *)id_to_ptr(nid);
+	}
+}
+
+static struct node* lookup_node_and_path_by_id_locked(struct fuse* fuse, __u64 nid,
+	char* buf, size_t bufsize)
+{
+	struct node* node = lookup_node_by_id_locked(fuse, nid);
+	if (node && get_node_path_locked(node, buf, bufsize) < 0) {
+		node = NULL;
+	}
+	return node;
+}
+
+static struct node *lookup_child_by_name_locked(struct node *node, const char *name)
+{
+	for (node = node->child; node; node = node->next) {
+		/* use exact string comparison, nodes that differ by case
+		 * must be considered distinct even if they refer to the same
+		 * underlying file as otherwise operations such as "mv x x"
+		 * will not work because the source and target nodes are the same. */
+		if (!strcmp(name, node->name) && !node->deleted) {
+			return node;
+		}
+	}
+	return 0;
+}
+
+static struct node* acquire_or_create_child_locked(
+	struct fuse* fuse, struct node* parent,
+	const char* name, const char* actual_name)
+{
+	struct node* child = lookup_child_by_name_locked(parent, name);
+	if (child) {
+		acquire_node_locked(child);
+	}
+	else {
+		child = create_node_locked(fuse, parent, name, actual_name);
+	}
+	return child;
+}
+
+static void fuse_status(struct fuse *fuse, __u64 unique, int err)
+{
+	struct fuse_out_header hdr;
+	hdr.len = sizeof(hdr);
+	hdr.error = err;
+	hdr.unique = unique;
+	write(fuse->fd, &hdr, sizeof(hdr));
+}
+
+static void fuse_reply(struct fuse *fuse, __u64 unique, void *data, int len)
+{
+	struct fuse_out_header hdr;
+	struct iovec vec[2];
+	int res;
+
+	hdr.len = len + sizeof(hdr);
+	hdr.error = 0;
+	hdr.unique = unique;
+
+	vec[0].iov_base = &hdr;
+	vec[0].iov_len = sizeof(hdr);
+	vec[1].iov_base = data;
+	vec[1].iov_len = len;
+
+	res = writev(fuse->fd, vec, 2);
+	if (res < 0) {
+		// ERROR("*** REPLY FAILED *** %d\n", errno);
+	}
+}
+
+static int fuse_reply_entry(struct fuse* fuse, __u64 unique,
+	struct node* parent, const char* name, const char* actual_name,
+	const char* path)
+{
+	struct node* node;
+	struct fuse_entry_out out;
+	struct stat s;
+
+	if (lstat(path, &s) < 0) {
+		return -errno;
+	}
+
+	pthread_mutex_lock(&fuse->global->lock);
+	node = acquire_or_create_child_locked(fuse, parent, name, actual_name);
+	if (!node) {
+		pthread_mutex_unlock(&fuse->global->lock);
+		return -ENOMEM;
+	}
+	memset(&out, 0, sizeof(out));
+	attr_from_stat(fuse, &out.attr, &s, node);
+	out.attr_valid = 10;
+	out.entry_valid = 10;
+	out.nodeid = node->nid;
+	out.generation = node->gen;
+	pthread_mutex_unlock(&fuse->global->lock);
+	fuse_reply(fuse, unique, &out, sizeof(out));
+	return NO_STATUS;
+}
+
+static int fuse_reply_attr(struct fuse* fuse, __u64 unique, const struct node* node,
+	const char* path)
+{
+	struct fuse_attr_out out;
+	struct stat s;
+
+	if (lstat(path, &s) < 0) {
+		return -errno;
+	}
+	memset(&out, 0, sizeof(out));
+	attr_from_stat(fuse, &out.attr, &s, node);
+	out.attr_valid = 10;
+	fuse_reply(fuse, unique, &out, sizeof(out));
+	return NO_STATUS;
+}
+
+static void fuse_notify_delete(struct fuse* fuse, const __u64 parent,
+	const __u64 child, const char* name) {
+	struct fuse_out_header hdr;
+	struct fuse_notify_delete_out data;
+	struct iovec vec[3];
+	size_t namelen = strlen(name);
+	int res;
+
+	hdr.len = sizeof(hdr) + sizeof(data) + namelen + 1;
+	hdr.error = FUSE_NOTIFY_DELETE;
+	hdr.unique = 0;
+
+	data.parent = parent;
+	data.child = child;
+	data.namelen = namelen;
+	data.padding = 0;
+
+	vec[0].iov_base = &hdr;
+	vec[0].iov_len = sizeof(hdr);
+	vec[1].iov_base = &data;
+	vec[1].iov_len = sizeof(data);
+	vec[2].iov_base = (void*)name;
+	vec[2].iov_len = namelen + 1;
+
+	res = writev(fuse->fd, vec, 3);
+	/* Ignore ENOENT, since other views may not have seen the entry */
+	if (res < 0 && errno != ENOENT) {
+		// ERROR("*** NOTIFY FAILED *** %d\n", errno);
+	}
+}
+
+static int handle_lookup(struct fuse* fuse, struct fuse_handler* handler,
+	const struct fuse_in_header *hdr, const char* name)
+{
+	struct node* parent_node;
+	char parent_path[PATH_MAX];
+	char child_path[PATH_MAX];
+	const char* actual_name;
+
+	pthread_mutex_lock(&fuse->global->lock);
+	parent_node = lookup_node_and_path_by_id_locked(fuse, hdr->nodeid,
+		parent_path, sizeof(parent_path));
+
+	pthread_mutex_unlock(&fuse->global->lock);
+
+	if (!parent_node || !(actual_name = find_file_within(parent_path, name,
+		child_path, sizeof(child_path), 1))) {
+		return -ENOENT;
+	}
+	if (!check_caller_access_to_name(fuse, hdr, parent_node, name, R_OK)) {
+		return -EACCES;
+	}
+
+	return fuse_reply_entry(fuse, hdr->unique, parent_node, name, actual_name, child_path);
+}
+
+static int handle_forget(struct fuse* fuse, struct fuse_handler* handler,
+	const struct fuse_in_header *hdr, const struct fuse_forget_in *req)
+{
+	struct node* node;
+
+	pthread_mutex_lock(&fuse->global->lock);
+	node = lookup_node_by_id_locked(fuse, hdr->nodeid);
+
+	if (node) {
+		__u64 n = req->nlookup;
+		while (n--) {
+			release_node_locked(node);
+		}
+	}
+	pthread_mutex_unlock(&fuse->global->lock);
+	return NO_STATUS; /* no reply */
+}
+
+static int handle_getattr(struct fuse* fuse, struct fuse_handler* handler,
+	const struct fuse_in_header *hdr, const struct fuse_getattr_in *req)
+{
+	struct node* node;
+	char path[PATH_MAX];
+
+	pthread_mutex_lock(&fuse->global->lock);
+	node = lookup_node_and_path_by_id_locked(fuse, hdr->nodeid, path, sizeof(path));
+
+	pthread_mutex_unlock(&fuse->global->lock);
+
+	if (!node) {
+		return -ENOENT;
+	}
+	if (!check_caller_access_to_node(fuse, hdr, node, R_OK)) {
+		return -EACCES;
+	}
+
+	return fuse_reply_attr(fuse, hdr->unique, node, path);
+}
+
+static int handle_setattr(struct fuse* fuse, struct fuse_handler* handler,
+	const struct fuse_in_header *hdr, const struct fuse_setattr_in *req)
+{
+	struct node* node;
+	char path[PATH_MAX];
+	struct timespec times[2];
+
+	pthread_mutex_lock(&fuse->global->lock);
+	node = lookup_node_and_path_by_id_locked(fuse, hdr->nodeid, path, sizeof(path));
+
+	pthread_mutex_unlock(&fuse->global->lock);
+
+	if (!node) {
+		return -ENOENT;
+	}
+
+	if (!(req->valid & FATTR_FH) &&
+		!check_caller_access_to_node(fuse, hdr, node, W_OK)) {
+		return -EACCES;
+	}
+
+	/* XXX: incomplete implementation on purpose.
+	 * chmod/chown should NEVER be implemented.*/
+
+	if ((req->valid & FATTR_SIZE) && truncate64(path, req->size) < 0) {
+		return -errno;
+	}
+
+	/* Handle changing atime and mtime.  If FATTR_ATIME_and FATTR_ATIME_NOW
+	 * are both set, then set it to the current time.  Else, set it to the
+	 * time specified in the request.  Same goes for mtime.  Use utimensat(2)
+	 * as it allows ATIME and MTIME to be changed independently, and has
+	 * nanosecond resolution which fuse also has.
+	 */
+	if (req->valid & (FATTR_ATIME | FATTR_MTIME)) {
+		times[0].tv_nsec = UTIME_OMIT;
+		times[1].tv_nsec = UTIME_OMIT;
+		if (req->valid & FATTR_ATIME) {
+			if (req->valid & FATTR_ATIME_NOW) {
+				times[0].tv_nsec = UTIME_NOW;
+			}
+			else {
+				times[0].tv_sec = req->atime;
+				times[0].tv_nsec = req->atimensec;
+			}
+		}
+		if (req->valid & FATTR_MTIME) {
+			if (req->valid & FATTR_MTIME_NOW) {
+				times[1].tv_nsec = UTIME_NOW;
+			}
+			else {
+				times[1].tv_sec = req->mtime;
+				times[1].tv_nsec = req->mtimensec;
+			}
+		}
+
+		if (utimensat(-1, path, times, 0) < 0) {
+			return -errno;
+		}
+	}
+	return fuse_reply_attr(fuse, hdr->unique, node, path);
+}
+
+static int handle_mknod(struct fuse* fuse, struct fuse_handler* handler,
+	const struct fuse_in_header* hdr, const struct fuse_mknod_in* req, const char* name)
+{
+	struct node* parent_node;
+	char parent_path[PATH_MAX];
+	char child_path[PATH_MAX];
+	const char* actual_name;
+
+	pthread_mutex_lock(&fuse->global->lock);
+	parent_node = lookup_node_and_path_by_id_locked(fuse, hdr->nodeid,
+		parent_path, sizeof(parent_path));
+
+	pthread_mutex_unlock(&fuse->global->lock);
+
+	if (!parent_node || !(actual_name = find_file_within(parent_path, name,
+		child_path, sizeof(child_path), 1))) {
+		return -ENOENT;
+	}
+	if (!check_caller_access_to_name(fuse, hdr, parent_node, name, W_OK)) {
+		return -EACCES;
+	}
+	__u32 mode = (req->mode & (~0777)) | 0664;
+	if (mknod(child_path, mode, req->rdev) < 0) {
+		return -errno;
+	}
+	return fuse_reply_entry(fuse, hdr->unique, parent_node, name, actual_name, child_path);
+}
+
+static int handle_mkdir(struct fuse* fuse, struct fuse_handler* handler,
+	const struct fuse_in_header* hdr, const struct fuse_mkdir_in* req, const char* name)
+{
+	struct node* parent_node;
+	char parent_path[PATH_MAX];
+	char child_path[PATH_MAX];
+	const char* actual_name;
+
+	pthread_mutex_lock(&fuse->global->lock);
+	parent_node = lookup_node_and_path_by_id_locked(fuse, hdr->nodeid,
+		parent_path, sizeof(parent_path));
+
+	pthread_mutex_unlock(&fuse->global->lock);
+
+	if (!parent_node || !(actual_name = find_file_within(parent_path, name,
+		child_path, sizeof(child_path), 1))) {
+		return -ENOENT;
+	}
+	if (!check_caller_access_to_name(fuse, hdr, parent_node, name, W_OK)) {
+		return -EACCES;
+	}
+	__u32 mode = (req->mode & (~0777)) | 0775;
+	if (mkdir(child_path, mode) < 0) {
+		return -errno;
+	}
+
+	/* When creating /Android/data and /Android/obb, mark them as .nomedia */
+	if (parent_node->perm == PERM_ANDROID && !strcasecmp(name, "data")) {
+		char nomedia[PATH_MAX];
+		snprintf(nomedia, PATH_MAX, "%s/.nomedia", child_path);
+		if (touch(nomedia, 0664) != 0) {
+			return -ENOENT;
+		}
+	}
+	if (parent_node->perm == PERM_ANDROID && !strcasecmp(name, "obb")) {
+		char nomedia[PATH_MAX];
+		snprintf(nomedia, PATH_MAX, "%s/.nomedia", fuse->global->obb_path);
+		if (touch(nomedia, 0664) != 0) {
+			return -ENOENT;
+		}
+	}
+
+	return fuse_reply_entry(fuse, hdr->unique, parent_node, name, actual_name, child_path);
+}
+
+static int handle_unlink(struct fuse* fuse, struct fuse_handler* handler,
+	const struct fuse_in_header* hdr, const char* name)
+{
+	struct node* parent_node;
+	struct node* child_node;
+	char parent_path[PATH_MAX];
+	char child_path[PATH_MAX];
+
+	pthread_mutex_lock(&fuse->global->lock);
+	parent_node = lookup_node_and_path_by_id_locked(fuse, hdr->nodeid,
+		parent_path, sizeof(parent_path));
+
+	pthread_mutex_unlock(&fuse->global->lock);
+
+	if (!parent_node || !find_file_within(parent_path, name,
+		child_path, sizeof(child_path), 1)) {
+		return -ENOENT;
+	}
+	if (!check_caller_access_to_name(fuse, hdr, parent_node, name, W_OK)) {
+		return -EACCES;
+	}
+	if (unlink(child_path) < 0) {
+		return -errno;
+	}
+	pthread_mutex_lock(&fuse->global->lock);
+	child_node = lookup_child_by_name_locked(parent_node, name);
+	if (child_node) {
+		child_node->deleted = true;
+	}
+	pthread_mutex_unlock(&fuse->global->lock);
+	if (parent_node && child_node) {
+		/* Tell all other views that node is gone */
+
+		if (fuse != fuse->global->fuse_default) {
+			fuse_notify_delete(fuse->global->fuse_default, parent_node->nid, child_node->nid, name);
+		}
+		if (fuse != fuse->global->fuse_read) {
+			fuse_notify_delete(fuse->global->fuse_read, parent_node->nid, child_node->nid, name);
+		}
+		if (fuse != fuse->global->fuse_write) {
+			fuse_notify_delete(fuse->global->fuse_write, parent_node->nid, child_node->nid, name);
+		}
+	}
+	return 0;
+}
+
+static int handle_rmdir(struct fuse* fuse, struct fuse_handler* handler,
+	const struct fuse_in_header* hdr, const char* name)
+{
+	struct node* child_node;
+	struct node* parent_node;
+	char parent_path[PATH_MAX];
+	char child_path[PATH_MAX];
+
+	pthread_mutex_lock(&fuse->global->lock);
+	parent_node = lookup_node_and_path_by_id_locked(fuse, hdr->nodeid,
+		parent_path, sizeof(parent_path));
+
+	pthread_mutex_unlock(&fuse->global->lock);
+
+	if (!parent_node || !find_file_within(parent_path, name,
+		child_path, sizeof(child_path), 1)) {
+		return -ENOENT;
+	}
+	if (!check_caller_access_to_name(fuse, hdr, parent_node, name, W_OK)) {
+		return -EACCES;
+	}
+	if (rmdir(child_path) < 0) {
+		return -errno;
+	}
+	pthread_mutex_lock(&fuse->global->lock);
+	child_node = lookup_child_by_name_locked(parent_node, name);
+	if (child_node) {
+		child_node->deleted = true;
+	}
+	pthread_mutex_unlock(&fuse->global->lock);
+	if (parent_node && child_node) {
+		/* Tell all other views that node is gone */
+
+		if (fuse != fuse->global->fuse_default) {
+			fuse_notify_delete(fuse->global->fuse_default, parent_node->nid, child_node->nid, name);
+		}
+		if (fuse != fuse->global->fuse_read) {
+			fuse_notify_delete(fuse->global->fuse_read, parent_node->nid, child_node->nid, name);
+		}
+		if (fuse != fuse->global->fuse_write) {
+			fuse_notify_delete(fuse->global->fuse_write, parent_node->nid, child_node->nid, name);
+		}
+	}
+	return 0;
+}
+
+static int handle_rename(struct fuse* fuse, struct fuse_handler* handler,
+	const struct fuse_in_header* hdr, const struct fuse_rename_in* req,
+	const char* old_name, const char* new_name)
+{
+	struct node* old_parent_node;
+	struct node* new_parent_node;
+	struct node* child_node;
+	char old_parent_path[PATH_MAX];
+	char new_parent_path[PATH_MAX];
+	char old_child_path[PATH_MAX];
+	char new_child_path[PATH_MAX];
+	const char* new_actual_name;
+	int res;
+	int search;
+
+	pthread_mutex_lock(&fuse->global->lock);
+	old_parent_node = lookup_node_and_path_by_id_locked(fuse, hdr->nodeid,
+		old_parent_path, sizeof(old_parent_path));
+	new_parent_node = lookup_node_and_path_by_id_locked(fuse, req->newdir,
+		new_parent_path, sizeof(new_parent_path));
+
+	if (!old_parent_node || !new_parent_node) {
+		res = -ENOENT;
+		goto lookup_error;
+	}
+	if (!check_caller_access_to_name(fuse, hdr, old_parent_node, old_name, W_OK)) {
+		res = -EACCES;
+		goto lookup_error;
+	}
+	if (!check_caller_access_to_name(fuse, hdr, new_parent_node, new_name, W_OK)) {
+		res = -EACCES;
+		goto lookup_error;
+	}
+	child_node = lookup_child_by_name_locked(old_parent_node, old_name);
+	if (!child_node || get_node_path_locked(child_node,
+		old_child_path, sizeof(old_child_path)) < 0) {
+		res = -ENOENT;
+		goto lookup_error;
+	}
+	acquire_node_locked(child_node);
+	pthread_mutex_unlock(&fuse->global->lock);
+
+	/* Special case for renaming a file where destination is same path
+	 * differing only by case.  In this case we don't want to look for a case
+	 * insensitive match.  This allows commands like "mv foo FOO" to work as expected.
+	 */
+	search = old_parent_node != new_parent_node
+		|| strcasecmp(old_name, new_name);
+	if (!(new_actual_name = find_file_within(new_parent_path, new_name,
+		new_child_path, sizeof(new_child_path), search))) {
+		res = -ENOENT;
+		goto io_error;
+	}
+
+
+	res = rename(old_child_path, new_child_path);
+	if (res < 0) {
+		res = -errno;
+		goto io_error;
+	}
+
+	pthread_mutex_lock(&fuse->global->lock);
+	res = rename_node_locked(child_node, new_name, new_actual_name);
+	if (!res) {
+		remove_node_from_parent_locked(child_node);
+		derive_permissions_locked(fuse, new_parent_node, child_node);
+		derive_permissions_recursive_locked(fuse, child_node);
+		add_node_to_parent_locked(child_node, new_parent_node);
+	}
+	goto done;
+
+io_error:
+	pthread_mutex_lock(&fuse->global->lock);
+done:
+	release_node_locked(child_node);
+lookup_error:
+	pthread_mutex_unlock(&fuse->global->lock);
+	return res;
+
+}
+
+static int open_flags_to_access_mode(int open_flags) {
+	if ((open_flags & O_ACCMODE) == O_RDONLY) {
+		return R_OK;
+	}
+	else if ((open_flags & O_ACCMODE) == O_WRONLY) {
+		return W_OK;
+	}
+	else {
+		/* Probably O_RDRW, but treat as default to be safe */
+		return R_OK | W_OK;
+	}
+}
+
+static int handle_open(struct fuse* fuse, struct fuse_handler* handler,
+	const struct fuse_in_header* hdr, const struct fuse_open_in* req)
+{
+	struct node* node;
+	char path[PATH_MAX];
+	struct fuse_open_out out;
+	struct handle *h;
+
+	pthread_mutex_lock(&fuse->global->lock);
+	node = lookup_node_and_path_by_id_locked(fuse, hdr->nodeid, path, sizeof(path));
+
+	pthread_mutex_unlock(&fuse->global->lock);
+
+	if (!node) {
+		return -ENOENT;
+	}
+	if (!check_caller_access_to_node(fuse, hdr, node,
+		open_flags_to_access_mode(req->flags))) {
+		return -EACCES;
+	}
+	h = (struct handle *)malloc(sizeof(*h));
+	if (!h) {
+		return -ENOMEM;
+	}
+	h->fd = open(path, req->flags);
+	if (h->fd < 0) {
+		free(h);
+		return -errno;
+	}
+	out.fh = ptr_to_id(h);
+	out.open_flags = 0;
+	out.padding = 0;
+	fuse_reply(fuse, hdr->unique, &out, sizeof(out));
+	return NO_STATUS;
+}
+
+static int handle_read(struct fuse* fuse, struct fuse_handler* handler,
+	const struct fuse_in_header* hdr, const struct fuse_read_in* req)
+{
+	struct handle *h = (struct handle *)id_to_ptr(req->fh);
+	__u64 unique = hdr->unique;
+	__u32 size = req->size;
+	__u64 offset = req->offset;
+	int res;
+	__u8 *read_buffer = (__u8 *)((uintptr_t)(handler->read_buffer + PAGE_SIZE) & ~((uintptr_t)PAGE_SIZE - 1));
+
+	/* Don't access any other fields of hdr or req beyond this point, the read buffer
+	 * overlaps the request buffer and will clobber data in the request.  This
+	 * saves us 128KB per request handler thread at the cost of this scary comment. */
+
+
+	if (size > MAX_READ) {
+		return -EINVAL;
+	}
+	res = pread64(h->fd, read_buffer, size, offset);
+	if (res < 0) {
+		return -errno;
+	}
+	fuse_reply(fuse, unique, read_buffer, res);
+	return NO_STATUS;
+}
+
+static int handle_write(struct fuse* fuse, struct fuse_handler* handler,
+	const struct fuse_in_header* hdr, const struct fuse_write_in* req,
+	const void* buffer)
+{
+	struct fuse_write_out out;
+	struct handle *h = (struct handle *)id_to_ptr(req->fh);
+	int res;
+	__u8 aligned_buffer[req->size] __attribute__((__aligned__(PAGE_SIZE)));
+
+	if (req->flags & O_DIRECT) {
+		memcpy(aligned_buffer, buffer, req->size);
+		buffer = (const __u8*)aligned_buffer;
+	}
+
+
+	res = pwrite64(h->fd, buffer, req->size, req->offset);
+	if (res < 0) {
+		return -errno;
+	}
+	out.size = res;
+	out.padding = 0;
+	fuse_reply(fuse, hdr->unique, &out, sizeof(out));
+	return NO_STATUS;
+}
+
+static int handle_statfs(struct fuse* fuse, struct fuse_handler* handler,
+	const struct fuse_in_header* hdr)
+{
+	char path[PATH_MAX];
+	struct statfs stat;
+	struct fuse_statfs_out out;
+	int res;
+
+	pthread_mutex_lock(&fuse->global->lock);
+
+	res = get_node_path_locked(&fuse->global->root, path, sizeof(path));
+	pthread_mutex_unlock(&fuse->global->lock);
+	if (res < 0) {
+		return -ENOENT;
+	}
+	if (statfs(fuse->global->root.name, &stat) < 0) {
+		return -errno;
+	}
+	memset(&out, 0, sizeof(out));
+	out.st.blocks = stat.f_blocks;
+	out.st.bfree = stat.f_bfree;
+	out.st.bavail = stat.f_bavail;
+	out.st.files = stat.f_files;
+	out.st.ffree = stat.f_ffree;
+	out.st.bsize = stat.f_bsize;
+	out.st.namelen = stat.f_namelen;
+	out.st.frsize = stat.f_frsize;
+	fuse_reply(fuse, hdr->unique, &out, sizeof(out));
+	return NO_STATUS;
+}
+
+static int handle_release(struct fuse* fuse, struct fuse_handler* handler,
+	const struct fuse_in_header* hdr, const struct fuse_release_in* req)
+{
+	struct handle *h = (struct handle *)id_to_ptr(req->fh);
+
+
+	close(h->fd);
+	free(h);
+	return 0;
+}
+
+static int handle_fsync(struct fuse* fuse, struct fuse_handler* handler,
+	const struct fuse_in_header* hdr, const struct fuse_fsync_in* req)
+{
+	bool is_dir = (hdr->opcode == FUSE_FSYNCDIR);
+	bool is_data_sync = req->fsync_flags & 1;
+
+	int fd = -1;
+	if (is_dir) {
+		struct dirhandle *dh = (struct dirhandle *)id_to_ptr(req->fh);
+		fd = dirfd(dh->d);
+	}
+	else {
+		struct handle *h = (struct handle *)id_to_ptr(req->fh);
+		fd = h->fd;
+	}
+
+
+	int res = is_data_sync ? fdatasync(fd) : fsync(fd);
+	if (res == -1) {
+		return -errno;
+	}
+	return 0;
+}
+
+static int handle_flush(struct fuse* fuse, struct fuse_handler* handler,
+	const struct fuse_in_header* hdr)
+{
+	return 0;
+}
+
+static int handle_opendir(struct fuse* fuse, struct fuse_handler* handler,
+	const struct fuse_in_header* hdr, const struct fuse_open_in* req)
+{
+	struct node* node;
+	char path[PATH_MAX];
+	struct fuse_open_out out;
+	struct dirhandle *h;
+
+	pthread_mutex_lock(&fuse->global->lock);
+	node = lookup_node_and_path_by_id_locked(fuse, hdr->nodeid, path, sizeof(path));
+
+	pthread_mutex_unlock(&fuse->global->lock);
+
+	if (!node) {
+		return -ENOENT;
+	}
+	if (!check_caller_access_to_node(fuse, hdr, node, R_OK)) {
+		return -EACCES;
+	}
+	h = (struct dirhandle *)malloc(sizeof(*h));
+	if (!h) {
+		return -ENOMEM;
+	}
+
+	h->d = opendir(path);
+	if (!h->d) {
+		free(h);
+		return -errno;
+	}
+	out.fh = ptr_to_id(h);
+	out.open_flags = 0;
+	out.padding = 0;
+	fuse_reply(fuse, hdr->unique, &out, sizeof(out));
+	return NO_STATUS;
+}
+
+static int handle_readdir(struct fuse* fuse, struct fuse_handler* handler,
+	const struct fuse_in_header* hdr, const struct fuse_read_in* req)
+{
+	char buffer[8192];
+	struct fuse_dirent *fde = (struct fuse_dirent*) buffer;
+	struct dirent *de;
+	struct dirhandle *h = (struct dirhandle *)id_to_ptr(req->fh);
+
+	if (req->offset == 0) {
+		/* rewinddir() might have been called above us, so rewind here too */
+		rewinddir(h->d);
+	}
+	de = readdir(h->d);
+	if (!de) {
+		return 0;
+	}
+	fde->ino = FUSE_UNKNOWN_INO;
+	/* increment the offset so we can detect when rewinddir() seeks back to the beginning */
+	fde->off = req->offset + 1;
+	fde->type = de->d_type;
+	fde->namelen = strlen(de->d_name);
+	memcpy(fde->name, de->d_name, fde->namelen + 1);
+	fuse_reply(fuse, hdr->unique, fde,
+		FUSE_DIRENT_ALIGN(sizeof(struct fuse_dirent) + fde->namelen));
+	return NO_STATUS;
+}
+
+static int handle_releasedir(struct fuse* fuse, struct fuse_handler* handler,
+	const struct fuse_in_header* hdr, const struct fuse_release_in* req)
+{
+	struct dirhandle *h = (struct dirhandle *)id_to_ptr(req->fh);
+	closedir(h->d);
+	free(h);
+	return 0;
+}
+
+static int handle_init(struct fuse* fuse, struct fuse_handler* handler,
+	const struct fuse_in_header* hdr, const struct fuse_init_in* req)
+{
+	struct fuse_init_out out;
+	size_t fuse_struct_size;
+
+	// TRACE("[%d] INIT ver=%d.%d maxread=%d flags=%x\n",
+		//handler->token, req->major, req->minor, req->max_readahead, req->flags);
+	/* Kernel 2.6.16 is the first stable kernel with struct fuse_init_out
+	 * defined (fuse version 7.6). The structure is the same from 7.6 through
+	 * 7.22. Beginning with 7.23, the structure increased in size and added
+	 * new parameters.
+	 */
+	if (req->major != FUSE_KERNEL_VERSION || req->minor < 6) {
+		return -1;
+	}
+
+	/* We limit ourselves to 15 because we don't handle BATCH_FORGET yet */
+	out.minor = MIN(req->minor, 15);
+	fuse_struct_size = sizeof(out);
+#if defined(FUSE_COMPAT_22_INIT_OUT_SIZE)
+	/* FUSE_KERNEL_VERSION >= 23. */
+
+	/* If the kernel only works on minor revs older than or equal to 22,
+	 * then use the older structure size since this code only uses the 7.22
+	 * version of the structure. */
+	if (req->minor <= 22) {
+		fuse_struct_size = FUSE_COMPAT_22_INIT_OUT_SIZE;
+	}
+#endif
+
+	out.major = FUSE_KERNEL_VERSION;
+	out.max_readahead = req->max_readahead;
+	out.flags = FUSE_ATOMIC_O_TRUNC | FUSE_BIG_WRITES;
+	out.max_background = 32;
+	out.congestion_threshold = 32;
+	out.max_write = MAX_WRITE;
+	fuse_reply(fuse, hdr->unique, &out, fuse_struct_size);
+	return NO_STATUS;
+}
+
+static int handle_canonical_path(struct fuse* fuse, struct fuse_handler* handler,
+	const struct fuse_in_header *hdr)
+{
+	struct node* node;
+	char path[PATH_MAX];
+	int len;
+
+	pthread_mutex_lock(&fuse->global->lock);
+	node = lookup_node_and_path_by_id_locked(fuse, hdr->nodeid,
+		path, sizeof(path));
+	pthread_mutex_unlock(&fuse->global->lock);
+
+	if (!node) {
+		return -ENOENT;
+	}
+	if (!check_caller_access_to_node(fuse, hdr, node, R_OK)) {
+		return -EACCES;
+	}
+	len = strlen(path);
+	if (len + 1 > PATH_MAX)
+		len = PATH_MAX - 1;
+	path[PATH_MAX - 1] = 0;
+	fuse_reply(fuse, hdr->unique, path, len + 1);
+	return NO_STATUS;
+}
+
+
+static int handle_fuse_request(struct fuse *fuse, struct fuse_handler* handler,
+	const struct fuse_in_header *hdr, const void *data, size_t data_len)
+{
+	switch (hdr->opcode) {
+	case FUSE_LOOKUP: { /* bytez[] -> entry_out */
+		const char* name = (const char *)data;
+		return handle_lookup(fuse, handler, hdr, name);
+	}
+
+	case FUSE_FORGET: {
+		const struct fuse_forget_in *req = (const struct fuse_forget_in *)data;
+		return handle_forget(fuse, handler, hdr, req);
+	}
+
+	case FUSE_GETATTR: { /* getattr_in -> attr_out */
+		const struct fuse_getattr_in *req = (const struct fuse_getattr_in *)data;
+		return handle_getattr(fuse, handler, hdr, req);
+	}
+
+	case FUSE_SETATTR: { /* setattr_in -> attr_out */
+		const struct fuse_setattr_in *req = (const struct fuse_setattr_in *)data;
+		return handle_setattr(fuse, handler, hdr, req);
+	}
+
+	case FUSE_MKNOD: { /* mknod_in, bytez[] -> entry_out */
+		const struct fuse_mknod_in *req = (const struct fuse_mknod_in *)data;
+		const char *name = ((const char*)data) + sizeof(*req);
+		return handle_mknod(fuse, handler, hdr, req, name);
+	}
+
+	case FUSE_MKDIR: { /* mkdir_in, bytez[] -> entry_out */
+		const struct fuse_mkdir_in *req = (const struct fuse_mkdir_in *)data;
+		const char *name = ((const char*)data) + sizeof(*req);
+		return handle_mkdir(fuse, handler, hdr, req, name);
+	}
+
+	case FUSE_UNLINK: { /* bytez[] -> */
+		const char* name = (const char *)data;
+		return handle_unlink(fuse, handler, hdr, name);
+	}
+
+	case FUSE_RMDIR: { /* bytez[] -> */
+		const char* name = (const char *)data;
+		return handle_rmdir(fuse, handler, hdr, name);
+	}
+
+	case FUSE_RENAME: { /* rename_in, oldname, newname ->  */
+		const struct fuse_rename_in *req = (const struct fuse_rename_in *)data;
+		const char *old_name = ((const char*)data) + sizeof(*req);
+		const char *new_name = old_name + strlen(old_name) + 1;
+		return handle_rename(fuse, handler, hdr, req, old_name, new_name);
+	}
+
+	case FUSE_OPEN: { /* open_in -> open_out */
+		const struct fuse_open_in *req = (const struct fuse_open_in *)data;
+		return handle_open(fuse, handler, hdr, req);
+	}
+
+	case FUSE_READ: { /* read_in -> byte[] */
+		const struct fuse_read_in *req = (const struct fuse_read_in *)data;
+		return handle_read(fuse, handler, hdr, req);
+	}
+
+	case FUSE_WRITE: { /* write_in, byte[write_in.size] -> write_out */
+		const struct fuse_write_in *req = (const struct fuse_write_in *)data;
+		const void* buffer = (const __u8*)data + sizeof(*req);
+		return handle_write(fuse, handler, hdr, req, buffer);
+	}
+
+	case FUSE_STATFS: { /* getattr_in -> attr_out */
+		return handle_statfs(fuse, handler, hdr);
+	}
+
+	case FUSE_RELEASE: { /* release_in -> */
+		const struct fuse_release_in *req = (const struct fuse_release_in *)data;
+		return handle_release(fuse, handler, hdr, req);
+	}
+
+	case FUSE_FSYNC:
+	case FUSE_FSYNCDIR: {
+		const struct fuse_fsync_in *req = (const struct fuse_fsync_in *)data;
+		return handle_fsync(fuse, handler, hdr, req);
+	}
+
+	case FUSE_FLUSH: {
+		return handle_flush(fuse, handler, hdr);
+	}
+
+	case FUSE_OPENDIR: { /* open_in -> open_out */
+		const struct fuse_open_in *req = (const struct fuse_open_in *)data;
+		return handle_opendir(fuse, handler, hdr, req);
+	}
+
+	case FUSE_READDIR: {
+		const struct fuse_read_in *req = (const struct fuse_read_in *)data;
+		return handle_readdir(fuse, handler, hdr, req);
+	}
+
+	case FUSE_RELEASEDIR: { /* release_in -> */
+		const struct fuse_release_in *req = (const struct fuse_release_in *)data;
+		return handle_releasedir(fuse, handler, hdr, req);
+	}
+
+	case FUSE_INIT: { /* init_in -> init_out */
+		const struct fuse_init_in *req = (const struct fuse_init_in *)data;
+		return handle_init(fuse, handler, hdr, req);
+	}
+
+	case FUSE_CANONICAL_PATH: { /* nodeid -> bytez[] */
+		return handle_canonical_path(fuse, handler, hdr);
+	}
+
+	default: {
+		return -ENOSYS;
+	}
+	}
+}
+
+static void handle_fuse_requests(struct fuse_handler* handler)
+{
+	ALOGE("main start handle_fuse_requests");
+	struct fuse* fuse = handler->fuse;
+	for (;;) {
+		ssize_t len = TEMP_FAILURE_RETRY(read(fuse->fd,
+			handler->request_buffer, sizeof(handler->request_buffer)));
+		if (len < 0) {
+			if (errno == ENODEV) {
+				exit(2);
+			}
+			continue;
+		}
+
+		if ((size_t)len < sizeof(struct fuse_in_header)) {
+			continue;
+		}
+
+		const struct fuse_in_header *hdr = (const struct fuse_in_header *)handler->request_buffer;
+		if (hdr->len != (size_t)len) {
+			continue;
+		}
+
+		const void *data = handler->request_buffer + sizeof(struct fuse_in_header);
+		size_t data_len = len - sizeof(struct fuse_in_header);
+		__u64 unique = hdr->unique;
+		int res = handle_fuse_request(fuse, handler, hdr, data, data_len);
+
+		/* We do not access the request again after this point because the underlying
+		 * buffer storage may have been reused while processing the request. */
+
+		if (res != NO_STATUS) {
+			if (res) {
+			}
+			fuse_status(fuse, unique, res);
+		}
+	}
+}
+
+static void* start_handler(void* data)
+{
+	struct fuse_handler* handler = (struct fuse_handler *)data;
+	handle_fuse_requests(handler);
+	return NULL;
+}
+
+static bool remove_str_to_int(void *key, void *value, void *context) {
+	Hashmap* map = (Hashmap *)context;
+	hashmapRemove(map, key);
+	free(key);
+	return true;
+}
+
+static bool package_parse_callback(pkg_info *info, void *userdata) {
+	struct fuse_global *global = (struct fuse_global *)userdata;
+
+	char* name = strdup(info->name);
+	hashmapPut(global->package_to_appid, name, (void*)(uintptr_t)info->uid);
+	packagelist_free(info);
+	return true;
+}
+
+static bool read_package_list(struct fuse_global* global) {
+	pthread_mutex_lock(&global->lock);
+
+	hashmapForEach(global->package_to_appid, remove_str_to_int, global->package_to_appid);
+
+	bool rc = packagelist_parse(package_parse_callback, global);
+
+	/* Regenerate ownership details using newly loaded mapping */
+	derive_permissions_recursive_locked(global->fuse_default, &global->root);
+
+	pthread_mutex_unlock(&global->lock);
+
+	return rc;
+}
+
+static void watch_package_list(struct fuse_global* global) {
+	struct inotify_event *event;
+	char event_buf[512];
+
+	int nfd = inotify_init();
+	if (nfd < 0) {
+		return;
+	}
+
+	bool active = false;
+	while (1) {
+		if (!active) {
+			int res = inotify_add_watch(nfd, PACKAGES_LIST_FILE, IN_DELETE_SELF);
+			if (res == -1) {
+				if (errno == ENOENT || errno == EACCES) {
+					/* Framework may not have created yet, sleep and retry */
+					sleep(3);
+					continue;
+				}
+				else {
+					return;
+				}
+			}
+
+			/* Watch above will tell us about any future changes, so
+			 * read the current state. */
+			if (read_package_list(global) == false) {
+				return;
+			}
+			active = true;
+		}
+
+		int event_pos = 0;
+		int res = read(nfd, event_buf, sizeof(event_buf));
+		if (res < (int) sizeof(*event)) {
+			if (errno == EINTR)
+				continue;
+			return;
+		}
+
+		while (res >= (int) sizeof(*event)) {
+			int event_size;
+			event = (struct inotify_event *) (event_buf + event_pos);
+
+			if ((event->mask & IN_IGNORED) == IN_IGNORED) {
+				/* Previously watched file was deleted, probably due to move
+				 * that swapped in new data; re-arm the watch and read. */
+				active = false;
+			}
+
+			event_size = sizeof(*event) + event->len;
+			res -= event_size;
+			event_pos += event_size;
+		}
+	}
 }
 
 static int usage() {
-    LOG(ERROR) << "usage: sdcard [OPTIONS] <source_path> <label>"
-               << "    -u: specify UID to run as"
-               << "    -g: specify GID to run as"
-               << "    -U: specify user ID that owns device"
-               << "    -m: source_path is multi-user"
-               << "    -w: runtime write mount has full write access"
-               << "    -P  preserve owners on the lower file system";
     return 1;
 }
 
+static int fuse_setup(struct fuse* fuse, gid_t gid, mode_t mask) {
+	char opts[256];
+
+	fuse->fd = open("/dev/fuse", O_RDWR);
+	if (fuse->fd == -1) {
+		return -1;
+	}
+
+	umount2(fuse->dest_path, MNT_DETACH);
+
+	snprintf(opts, sizeof(opts),
+		"fd=%i,rootmode=40000,default_permissions,allow_other,user_id=%d,group_id=%d",
+		fuse->fd, fuse->global->uid, fuse->global->gid);
+	if (mount("/dev/fuse", fuse->dest_path, "fuse", MS_NOSUID | MS_NODEV | MS_NOEXEC |
+		MS_NOATIME, opts) != 0) {
+		return -1;
+	}
+
+	fuse->gid = gid;
+	fuse->mask = mask;
+
+	return 0;
+}
+
+static void run(const char* source_path, const char* label, uid_t uid,
+	gid_t gid, userid_t userid, bool multi_user, bool full_write) {
+	struct fuse_global global;
+	struct fuse fuse_default;
+	struct fuse fuse_read;
+	struct fuse fuse_write;
+	struct fuse_handler handler_default;
+	struct fuse_handler handler_read;
+	struct fuse_handler handler_write;
+	pthread_t thread_default;
+	pthread_t thread_read;
+	pthread_t thread_write;
+
+	memset(&global, 0, sizeof(global));
+	memset(&fuse_default, 0, sizeof(fuse_default));
+	memset(&fuse_read, 0, sizeof(fuse_read));
+	memset(&fuse_write, 0, sizeof(fuse_write));
+	memset(&handler_default, 0, sizeof(handler_default));
+	memset(&handler_read, 0, sizeof(handler_read));
+	memset(&handler_write, 0, sizeof(handler_write));
+
+	pthread_mutex_init(&global.lock, NULL);
+	global.package_to_appid = hashmapCreate(256, str_hash, str_icase_equals);
+	global.uid = uid;
+	global.gid = gid;
+	global.multi_user = multi_user;
+	global.next_generation = 0;
+	global.inode_ctr = 1;
+
+	memset(&global.root, 0, sizeof(global.root));
+	global.root.nid = FUSE_ROOT_ID; /* 1 */
+	global.root.refcount = 2;
+	global.root.namelen = strlen(source_path);
+	global.root.name = strdup(source_path);
+	global.root.userid = userid;
+	global.root.uid = AID_ROOT;
+	global.root.under_android = false;
+
+	strcpy(global.source_path, source_path);
+
+	if (multi_user) {
+		global.root.perm = PERM_PRE_ROOT;
+		snprintf(global.obb_path, sizeof(global.obb_path), "%s/obb", source_path);
+	}
+	else {
+		global.root.perm = PERM_ROOT;
+		snprintf(global.obb_path, sizeof(global.obb_path), "%s/Android/obb", source_path);
+	}
+
+	fuse_default.global = &global;
+	fuse_read.global = &global;
+	fuse_write.global = &global;
+
+	global.fuse_default = &fuse_default;
+	global.fuse_read = &fuse_read;
+	global.fuse_write = &fuse_write;
+
+	snprintf(fuse_default.dest_path, PATH_MAX, "/mnt/runtime/default/%s", label);
+	snprintf(fuse_read.dest_path, PATH_MAX, "/mnt/runtime/read/%s", label);
+	snprintf(fuse_write.dest_path, PATH_MAX, "/mnt/runtime/write/%s", label);
+
+	handler_default.fuse = &fuse_default;
+	handler_read.fuse = &fuse_read;
+	handler_write.fuse = &fuse_write;
+
+	handler_default.token = 0;
+	handler_read.token = 1;
+	handler_write.token = 2;
+
+	umask(0);
+
+	if (multi_user) {
+		/* Multi-user storage is fully isolated per user, so "other"
+		 * permissions are completely masked off. */
+		if (fuse_setup(&fuse_default, AID_SDCARD_RW, 0006)
+			|| fuse_setup(&fuse_read, AID_EVERYBODY, 0027)
+			|| fuse_setup(&fuse_write, AID_EVERYBODY, full_write ? 0007 : 0027)) {
+			exit(1);
+		}
+	}
+	else {
+		/* Physical storage is readable by all users on device, but
+		 * the Android directories are masked off to a single user
+		 * deep inside attr_from_stat(). */
+		if (fuse_setup(&fuse_default, AID_SDCARD_RW, 0006)
+			|| fuse_setup(&fuse_read, AID_EVERYBODY, full_write ? 0027 : 0022)
+			|| fuse_setup(&fuse_write, AID_EVERYBODY, full_write ? 0007 : 0022)) {
+			// ERROR("failed to fuse_setup\n");
+			exit(1);
+		}
+	}
+
+	/* Drop privs */
+	if (setgroups(sizeof(kGroups) / sizeof(kGroups[0]), kGroups) < 0) {
+		exit(1);
+	}
+	if (setgid(gid) < 0) {
+		exit(1);
+	}
+	if (setuid(uid) < 0) {
+		exit(1);
+	}
+
+	if (multi_user) {
+		fs_prepare_dir(global.obb_path, 0775, uid, gid);
+	}
+
+	if (pthread_create(&thread_default, NULL, start_handler, &handler_default)
+		|| pthread_create(&thread_read, NULL, start_handler, &handler_read)
+		|| pthread_create(&thread_write, NULL, start_handler, &handler_write)) {
+		exit(1);
+	}
+
+	watch_package_list(&global);
+	exit(1);
+}
+
+static int sdcardfs_setup(const char *source_path, const char *dest_path, uid_t fsuid,
+	gid_t fsgid, bool multi_user, userid_t userid, gid_t gid, mode_t mask) {
+	char opts[256];
+
+	snprintf(opts, sizeof(opts),
+		"fsuid=%d,fsgid=%d,%smask=%d,userid=%d,gid=%d",
+		fsuid, fsgid, multi_user ? "multiuser," : "", mask, userid, gid);
+
+	if (mount(source_path, dest_path, "sdcardfs",
+		MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_NOATIME, opts) != 0) {
+		return -1;
+	}
+
+	return 0;
+}
+
+static void run_sdcardfs(const char* source_path, const char* label, uid_t uid,
+	gid_t gid, userid_t userid, bool multi_user, bool full_write) {
+	char dest_path_default[PATH_MAX];
+	char dest_path_read[PATH_MAX];
+	char dest_path_write[PATH_MAX];
+	char obb_path[PATH_MAX];
+	snprintf(dest_path_default, PATH_MAX, "/mnt/runtime/default/%s", label);
+	snprintf(dest_path_read, PATH_MAX, "/mnt/runtime/read/%s", label);
+	snprintf(dest_path_write, PATH_MAX, "/mnt/runtime/write/%s", label);
+
+	umask(0);
+	if (multi_user) {
+		/* Multi-user storage is fully isolated per user, so "other"
+		 * permissions are completely masked off. */
+		if (sdcardfs_setup(source_path, dest_path_default, uid, gid, multi_user, userid,
+			AID_SDCARD_RW, 0006)
+			|| sdcardfs_setup(source_path, dest_path_read, uid, gid, multi_user, userid,
+				AID_EVERYBODY, 0027)
+			|| sdcardfs_setup(source_path, dest_path_write, uid, gid, multi_user, userid,
+				AID_EVERYBODY, full_write ? 0007 : 0027)) {
+			exit(1);
+		}
+	}
+	else {
+		/* Physical storage is readable by all users on device, but
+		 * the Android directories are masked off to a single user
+		 * deep inside attr_from_stat(). */
+		if (sdcardfs_setup(source_path, dest_path_default, uid, gid, multi_user, userid,
+			AID_SDCARD_RW, 0006)
+			|| sdcardfs_setup(source_path, dest_path_read, uid, gid, multi_user, userid,
+				AID_EVERYBODY, full_write ? 0027 : 0022)
+			|| sdcardfs_setup(source_path, dest_path_write, uid, gid, multi_user, userid,
+				AID_EVERYBODY, full_write ? 0007 : 0022)) {
+			// ERROR("failed to fuse_setup\n");
+			exit(1);
+		}
+	}
+
+	/* Drop privs */
+	if (setgroups(sizeof(kGroups) / sizeof(kGroups[0]), kGroups) < 0) {
+		exit(1);
+	}
+	if (setgid(gid) < 0) {
+		exit(1);
+	}
+	if (setuid(uid) < 0) {
+		exit(1);
+	}
+
+	if (multi_user) {
+		snprintf(obb_path, sizeof(obb_path), "%s/obb", source_path);
+		fs_prepare_dir(&obb_path[0], 0775, uid, gid);
+	}
+
+	exit(0);
+}
+
+static bool supports_sdcardfs(void) {
+	FILE *fp;
+	char *buf = NULL;
+	size_t buflen = 0;
+
+	fp = fopen("/proc/filesystems", "r");
+	if (!fp) {
+		return false;
+	}
+	while ((getline(&buf, &buflen, fp)) > 0) {
+		if (strstr(buf, "sdcardfs\n")) {
+			free(buf);
+			fclose(fp);
+			return true;
+		}
+	}
+	free(buf);
+	fclose(fp);
+	return false;
+}
+
+static bool should_use_sdcardfs(void) {
+	char property[PROPERTY_VALUE_MAX];
+
+	// Allow user to have a strong opinion about state
+	property_get(PROP_SDCARDFS_USER, property, "");
+	if (!strcmp(property, "force_on")) {
+		ALOGW("User explicitly enabled sdcardfs");
+		return supports_sdcardfs();
+	}
+	else if (!strcmp(property, "force_off")) {
+		ALOGW("User explicitly disabled sdcardfs");
+		return false;
+	}
+
+	// Fall back to device opinion about state
+	if (property_get_bool(PROP_SDCARDFS_DEVICE, false)) {
+		ALOGW("Device explicitly enabled sdcardfs");
+		return supports_sdcardfs();
+	}
+	else {
+		ALOGW("Device explicitly disabled sdcardfs");
+		return false;
+	}
+}
+
 int main(int argc, char **argv) {
-    const char *source_path = NULL;
-    const char *label = NULL;
-    uid_t uid = 0;
-    gid_t gid = 0;
-    userid_t userid = 0;
-    bool multi_user = false;
-    bool full_write = false;
-    bool derive_gid = false;
+	ALOGE("main start");
+	const char *source_path = NULL;
+	const char *label = NULL;
+	uid_t uid = 0;
+	gid_t gid = 0;
+	userid_t userid = 0;
+	bool multi_user = false;
+	bool full_write = false;
+	    bool derive_gid = false;
     bool default_normal = false;
-    int i;
-    struct rlimit rlim;
-    int fs_version;
-
-    setenv("ANDROID_LOG_TAGS", "*:v", 1);
-    android::base::InitLogging(argv, android::base::LogdLogger(android::base::SYSTEM));
-
-    int opt;
-    while ((opt = getopt(argc, argv, "u:g:U:mwGi")) != -1) {
-        switch (opt) {
-            case 'u':
-                uid = strtoul(optarg, NULL, 10);
-                break;
-            case 'g':
-                gid = strtoul(optarg, NULL, 10);
-                break;
-            case 'U':
-                userid = strtoul(optarg, NULL, 10);
-                break;
-            case 'm':
-                multi_user = true;
-                break;
-            case 'w':
-                full_write = true;
-                break;
-            case 'G':
-                derive_gid = true;
-                break;
-            case 'i':
-                default_normal = true;
-                break;
-            case '?':
-            default:
-                return usage();
-        }
-    }
-
-    for (i = optind; i < argc; i++) {
-        char* arg = argv[i];
-        if (!source_path) {
-            source_path = arg;
-        } else if (!label) {
-            label = arg;
-        } else {
-            LOG(ERROR) << "too many arguments";
-            return usage();
-        }
-    }
-
-    if (!source_path) {
-        LOG(ERROR) << "no source path specified";
-        return usage();
-    }
-    if (!label) {
-        LOG(ERROR) << "no label specified";
-        return usage();
-    }
-    if (!uid || !gid) {
-        LOG(ERROR) << "uid and gid must be nonzero";
-        return usage();
-    }
-
-    rlim.rlim_cur = 8192;
-    rlim.rlim_max = 8192;
-    if (setrlimit(RLIMIT_NOFILE, &rlim) == -1) {
-        PLOG(ERROR) << "setting RLIMIT_NOFILE failed";
-    }
-
-    while ((fs_read_atomic_int("/data/.layout_version", &fs_version) == -1) || (fs_version < 3)) {
-        LOG(ERROR) << "installd fs upgrade not yet complete; waiting...";
-        sleep(1);
-    }
-
-    run_sdcardfs(source_path, label, uid, gid, userid, multi_user, full_write, derive_gid,
-                 default_normal, !should_use_sdcardfs());
-    return 1;
+	int i;
+	struct rlimit rlim;
+	int fs_version;
+
+	int opt;
+	while ((opt = getopt(argc, argv, "u:g:U:mwGi")) != -1) {
+		switch (opt) {
+		case 'u':
+			uid = strtoul(optarg, NULL, 10);
+			break;
+		case 'g':
+			gid = strtoul(optarg, NULL, 10);
+			break;
+		case 'U':
+			userid = strtoul(optarg, NULL, 10);
+			break;
+		case 'm':
+			multi_user = true;
+			break;
+		case 'w':
+			full_write = true;
+			break;
+        case 'G':
+            derive_gid = true;
+            break;
+        case 'i':
+            default_normal = true;
+            break;
+		case '?':
+		default:
+			return usage();
+		}
+	}
+	ALOGE("main start 2");
+	for (i = optind; i < argc; i++) {
+		char* arg = argv[i];
+		if (!source_path) {
+			source_path = arg;
+		}
+		else if (!label) {
+			label = arg;
+		}
+		else {
+			return usage();
+		}
+	}
+ALOGE("main start 3");
+	if (!source_path) {
+		return usage();
+	}
+	if (!label) {
+		return usage();
+	}
+	if (!uid || !gid) {
+		return usage();
+	}
+
+	rlim.rlim_cur = 8192;
+	rlim.rlim_max = 8192;
+ALOGE("main start 4");
+	while ((fs_read_atomic_int("/data/.layout_version", &fs_version) == -1) || (fs_version < 3)) {
+		sleep(1);
+	}
+
+	if (should_use_sdcardfs()) {
+		ALOGE("should_use_sdcardfs");
+	}
+		run(source_path, label, uid, gid, userid, multi_user, full_write);
+	return 1;
 }
