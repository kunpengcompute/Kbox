Copyright (C) 2021. Huawei Technologies Co., Ltd. 

This program is free software; you can redistribute it and/or modify
it under the terms of the Apache License, Version 2.0 and
only version 2 as published by the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
Apache 2.0 for more details.

diff --git a/adb/daemon/shell_service.cpp b/adb/daemon/shell_service.cpp
index 3c8f393..517538f 100644
--- a/adb/daemon/shell_service.cpp
+++ b/adb/daemon/shell_service.cpp
@@ -341,7 +341,8 @@ bool Subprocess::ForkAndExec(std::string* error) {
             TEMP_FAILURE_RETRY(
                 adb_write(oom_score_adj_fd, oom_score_adj_value, strlen(oom_score_adj_value)));
         }
-
+        // kbox do not use selinux
+	/*
 #ifdef __ANDROID_RECOVERY__
         // Special routine for recovery. Switch to shell domain when adbd is
         // is running with dropped privileged (i.e. not running as root) and
@@ -359,7 +360,7 @@ bool Subprocess::ForkAndExec(std::string* error) {
             LOG(FATAL) << "Failed to get SELinux context";
         }
 #endif
-
+        */
         if (command_.empty()) {
             // Spawn a login shell if we don't have a command.
             execle(_PATH_BSHELL, "-" _PATH_BSHELL, nullptr, cenv.data());
diff --git a/debuggerd/seccomp_policy/crash_dump.arm64.policy b/debuggerd/seccomp_policy/crash_dump.arm64.policy
index 9b3ef09..19b93d9 100644
--- a/debuggerd/seccomp_policy/crash_dump.arm64.policy
+++ b/debuggerd/seccomp_policy/crash_dump.arm64.policy
@@ -34,3 +34,6 @@ geteuid: 1
 getgid: 1
 getegid: 1
 getgroups: 1
+uname: 1
+mkdirat: 1
+sysinfo: 1
diff --git a/init/Android.bp b/init/Android.bp
index 6be7290..569421e 100644
--- a/init/Android.bp
+++ b/init/Android.bp
@@ -143,7 +143,12 @@ cc_library_static {
         type: "lite",
         export_proto_headers: true,
     },
-
+    cflags: [
+       "-Wall",
+       "-Werror",
+       "-Wno-unused-parameter",
+       "-Wno-unused-function",
+    ],
     target: {
         recovery: {
             cflags: ["-DRECOVERY"],
diff --git a/init/Android.mk b/init/Android.mk
index c4f7d34..43f9098 100644
--- a/init/Android.mk
+++ b/init/Android.mk
@@ -38,6 +38,10 @@ init_cflags += \
     -Wall -Wextra \
     -Wno-unused-parameter \
     -Werror \
+	-Wno-unused-function \
+
+
+
 
 # --
 
diff --git a/init/devices.cpp b/init/devices.cpp
index 159c75e..3cb07e5 100644
--- a/init/devices.cpp
+++ b/init/devices.cpp
@@ -385,6 +385,11 @@ std::vector<std::string> DeviceHandler::GetBlockDeviceSymlinks(const Uevent& uev
 
 void DeviceHandler::HandleDevice(const std::string& action, const std::string& devpath, bool block,
                                  int major, int minor, const std::vector<std::string>& links) const {
+    //std::string temp = devpath.substr(0, 11);
+    //if ((temp.compare("/dev/input/")) == 0) {
+    //    return;
+    //}
+
     if (action == "add") {
         MakeDevice(devpath, block, major, minor, links);
         for (const auto& link : links) {
@@ -465,6 +470,13 @@ void DeviceHandler::ColdbootDone() {
     skip_restorecon_ = false;
 }
 
+void DeviceHandler::ChinitDev(const char *path) {
+    std::vector<std::string> links;
+    auto[mode, uid, gid] = GetDevicePermissions(path, links);
+    chown(path, uid, gid);
+    chmod(path, mode);
+}
+
 DeviceHandler::DeviceHandler(std::vector<Permissions> dev_permissions,
                              std::vector<SysfsPermissions> sysfs_permissions,
                              std::vector<Subsystem> subsystems, std::set<std::string> boot_devices,
diff --git a/init/devices.h b/init/devices.h
index 9d39eaa..df4c8b5 100644
--- a/init/devices.h
+++ b/init/devices.h
@@ -120,7 +120,7 @@ class DeviceHandler : public UeventHandler {
     void ColdbootDone() override;
 
     std::vector<std::string> GetBlockDeviceSymlinks(const Uevent& uevent) const;
-
+    void ChinitDev(const char *path);
   private:
     bool FindPlatformDevice(std::string path, std::string* platform_device_path) const;
     std::tuple<mode_t, uid_t, gid_t> GetDevicePermissions(
diff --git a/init/first_stage_init.cpp b/init/first_stage_init.cpp
index 2b89940..6f03602 100644
--- a/init/first_stage_init.cpp
+++ b/init/first_stage_init.cpp
@@ -103,8 +103,7 @@ int FirstStageMain(int argc, char** argv) {
     if (REBOOT_BOOTLOADER_ON_PANIC) {
         InstallRebootSignalHandlers();
     }
-
-    boot_clock::time_point start_time = boot_clock::now();
+    //boot_clock::time_point start_time = boot_clock::now();
 
     std::vector<std::pair<std::string, int>> errors;
 #define CHECKCALL(x) \
@@ -117,17 +116,17 @@ int FirstStageMain(int argc, char** argv) {
     CHECKCALL(setenv("PATH", _PATH_DEFPATH, 1));
     // Get the basic filesystem setup we need put together in the initramdisk
     // on / and then we'll let the rc file figure out the rest.
-    CHECKCALL(mount("tmpfs", "/dev", "tmpfs", MS_NOSUID, "mode=0755"));
-    CHECKCALL(mkdir("/dev/pts", 0755));
+    // CHECKCALL(mount("tmpfs", "/dev", "tmpfs", MS_NOSUID, "mode=0755"));
+    CHECKCALL(mkdir("/dev/pts",0755));
     CHECKCALL(mkdir("/dev/socket", 0755));
-    CHECKCALL(mount("devpts", "/dev/pts", "devpts", 0, NULL));
+    // CHECKCALL(mount("devpts", "/dev/pts", "devpts", 0, NULL));
 #define MAKE_STR(x) __STRING(x)
-    CHECKCALL(mount("proc", "/proc", "proc", 0, "hidepid=2,gid=" MAKE_STR(AID_READPROC)));
+    // CHECKCALL(mount("proc", "/proc", "proc", 0, "hidepid=2,gid=" MAKE_STR(AID_READPROC)));
 #undef MAKE_STR
     // Don't expose the raw commandline to unprivileged processes.
-    CHECKCALL(chmod("/proc/cmdline", 0440));
-    gid_t groups[] = {AID_READPROC};
-    CHECKCALL(setgroups(arraysize(groups), groups));
+    // CHECKCALL(chmod("/proc/cmdline", 0440));
+    // gid_t groups[] = {AID_READPROC};
+    // CHECKCALL(setgroups(arraysize(groups), groups));
     CHECKCALL(mount("sysfs", "/sys", "sysfs", 0, NULL));
     CHECKCALL(mount("selinuxfs", "/sys/fs/selinux", "selinuxfs", 0, NULL));
 
@@ -136,7 +135,6 @@ int FirstStageMain(int argc, char** argv) {
     if constexpr (WORLD_WRITABLE_KMSG) {
         CHECKCALL(mknod("/dev/kmsg_debug", S_IFCHR | 0622, makedev(1, 11)));
     }
-
     CHECKCALL(mknod("/dev/random", S_IFCHR | 0666, makedev(1, 8)));
     CHECKCALL(mknod("/dev/urandom", S_IFCHR | 0666, makedev(1, 9)));
 
@@ -176,16 +174,15 @@ int FirstStageMain(int argc, char** argv) {
         for (const auto& [error_string, error_errno] : errors) {
             LOG(ERROR) << error_string << " " << strerror(error_errno);
         }
-        LOG(FATAL) << "Init encountered errors starting first stage, aborting";
+        LOG(INFO) << "Init encountered errors starting first stage, aborting";
     }
-
     LOG(INFO) << "init first stage started!";
 
     auto old_root_dir = std::unique_ptr<DIR, decltype(&closedir)>{opendir("/"), closedir};
     if (!old_root_dir) {
         PLOG(ERROR) << "Could not opendir(\"/\"), not freeing ramdisk";
     }
-
+#if 0
     struct stat old_root_info;
     if (stat("/", &old_root_info) != 0) {
         PLOG(ERROR) << "Could not stat(\"/\"), not freeing ramdisk";
@@ -234,7 +231,7 @@ int FirstStageMain(int argc, char** argv) {
     static constexpr uint32_t kNanosecondsPerMillisecond = 1e6;
     uint64_t start_ms = start_time.time_since_epoch().count() / kNanosecondsPerMillisecond;
     setenv("INIT_STARTED_AT", std::to_string(start_ms).c_str(), 1);
-
+#endif
     const char* path = "/system/bin/init";
     const char* args[] = {path, "selinux_setup", nullptr};
     execv(path, const_cast<char**>(args));
diff --git a/init/init.cpp b/init/init.cpp
index 6b03bc9..fdb10aa 100644
--- a/init/init.cpp
+++ b/init/init.cpp
@@ -347,10 +347,12 @@ static Result<Success> wait_for_coldboot_done_action(const BuiltinArguments& arg
 }
 
 static Result<Success> console_init_action(const BuiltinArguments& args) {
+#if 0
     std::string console = GetProperty("ro.boot.console", "");
     if (!console.empty()) {
         default_console = "/dev/" + console;
     }
+#endif
     return Success();
 }
 
@@ -361,7 +363,6 @@ static Result<Success> SetupCgroupsAction(const BuiltinArguments&) {
     if (!CgroupSetup()) {
         return ErrnoError() << "Failed to setup cgroups";
     }
-
     return Success();
 }
 
@@ -401,10 +402,9 @@ static void export_kernel_boot_props() {
         const char *default_value;
     } prop_map[] = {
         { "ro.boot.serialno",   "ro.serialno",   UNSET, },
-        { "ro.boot.mode",       "ro.bootmode",   "unknown", },
-        { "ro.boot.baseband",   "ro.baseband",   "unknown", },
-        { "ro.boot.bootloader", "ro.bootloader", "unknown", },
-        { "ro.boot.hardware",   "ro.hardware",   "unknown", },
+        { "ro.boot.mode",       "ro.bootmode",   "boot", },
+        { "ro.boot.baseband",   "ro.baseband",   "bird", },
+        { "ro.boot.bootloader", "ro.bootloader", "uboot", },
         { "ro.boot.revision",   "ro.revision",   "0", },
     };
     for (const auto& prop : prop_map) {
@@ -621,7 +621,7 @@ int SecondStageMain(int argc, char** argv) {
     }
 
     SetStdioToDevNull(argv);
-    InitKernelLogging(argv);
+    // InitKernelLogging(argv);
     LOG(INFO) << "init second stage started!";
 
     // Set init and its forked children's oom_adj.
@@ -642,10 +642,12 @@ int SecondStageMain(int argc, char** argv) {
 
     property_init();
 
+#if 0
     // If arguments are passed both on the command line and in DT,
     // properties set in DT always have priority over the command-line ones.
     process_kernel_dt();
     process_kernel_cmdline();
+#endif
 
     // Propagate the kernel variables to internal variables
     // used by init as well as the current required properties.
@@ -656,15 +658,14 @@ int SecondStageMain(int argc, char** argv) {
     property_set("ro.boottime.init.selinux", getenv("INIT_SELINUX_TOOK"));
 
     // Set libavb version for Framework-only OTA match in Treble build.
-    const char* avb_version = getenv("INIT_AVB_VERSION");
-    if (avb_version) property_set("ro.boot.avb_version", avb_version);
+    // const char* avb_version = getenv("INIT_AVB_VERSION");
+    // if (avb_version) property_set("ro.boot.avb_version", avb_version);
 
     // See if need to load debug props to allow adb root, when the device is unlocked.
     const char* force_debuggable_env = getenv("INIT_FORCE_DEBUGGABLE");
     if (force_debuggable_env && AvbHandle::IsDeviceUnlocked()) {
         load_debug_prop = "true"s == force_debuggable_env;
     }
-
     // Clean up our environment.
     unsetenv("INIT_STARTED_AT");
     unsetenv("INIT_SELINUX_TOOK");
@@ -680,7 +681,6 @@ int SecondStageMain(int argc, char** argv) {
     if (auto result = epoll.Open(); !result) {
         PLOG(FATAL) << result.error();
     }
-
     InstallSignalFdHandler(&epoll);
 
     property_load_boot_defaults(load_debug_prop);
@@ -724,8 +724,8 @@ int SecondStageMain(int argc, char** argv) {
     am.QueueBuiltinAction(wait_for_coldboot_done_action, "wait_for_coldboot_done");
     // ... so that we can start queuing up actions that require stuff from /dev.
     am.QueueBuiltinAction(MixHwrngIntoLinuxRngAction, "MixHwrngIntoLinuxRng");
-    am.QueueBuiltinAction(SetMmapRndBitsAction, "SetMmapRndBits");
-    am.QueueBuiltinAction(SetKptrRestrictAction, "SetKptrRestrict");
+    // am.QueueBuiltinAction(SetMmapRndBitsAction, "SetMmapRndBits");
+    // am.QueueBuiltinAction(SetKptrRestrictAction, "SetKptrRestrict");
     Keychords keychords;
     am.QueueBuiltinAction(
         [&epoll, &keychords](const BuiltinArguments& args) -> Result<Success> {
@@ -746,7 +746,7 @@ int SecondStageMain(int argc, char** argv) {
 
     // Repeat mix_hwrng_into_linux_rng in case /dev/hw_random or /dev/random
     // wasn't ready immediately after wait_for_coldboot_done
-    am.QueueBuiltinAction(MixHwrngIntoLinuxRngAction, "MixHwrngIntoLinuxRng");
+    // am.QueueBuiltinAction(MixHwrngIntoLinuxRngAction, "MixHwrngIntoLinuxRng");
 
     // Initialize binder before bringing up other system services
     am.QueueBuiltinAction(InitBinder, "InitBinder");
diff --git a/init/service.cpp b/init/service.cpp
index 2db548e..239b098 100644
--- a/init/service.cpp
+++ b/init/service.cpp
@@ -70,6 +70,7 @@ using android::base::WriteStringToFile;
 namespace android {
 namespace init {
 
+#if 0
 static Result<std::string> ComputeContextFromExecutable(const std::string& service_path) {
     std::string computed_context;
 
@@ -105,6 +106,7 @@ static Result<std::string> ComputeContextFromExecutable(const std::string& servi
     }
     return computed_context;
 }
+#endif
 
 Result<Success> Service::SetUpMountNamespace() const {
     constexpr unsigned int kSafeFlags = MS_NODEV | MS_NOEXEC | MS_NOSUID;
@@ -934,6 +936,7 @@ Result<Success> Service::Start() {
     }
 
     std::string scon;
+#if 0
     if (!seclabel_.empty()) {
         scon = seclabel_;
     } else {
@@ -943,6 +946,7 @@ Result<Success> Service::Start() {
         }
         scon = *result;
     }
+#endif
 
     if (!IsRuntimeApexReady() && !pre_apexd_) {
         // If this service is started before the runtime APEX gets available,
@@ -966,6 +970,7 @@ Result<Success> Service::Start() {
     if (pid == 0) {
         umask(077);
 
+#if 0
         if (auto result = EnterNamespaces(); !result) {
             LOG(FATAL) << "Service '" << name_ << "' could not enter namespaces: " << result.error();
         }
@@ -994,6 +999,7 @@ Result<Success> Service::Start() {
                            << "' could not set up PID namespace: " << result.error();
             }
         }
+#endif
 
         for (const auto& [key, value] : environment_vars_) {
             setenv(key.c_str(), value.c_str(), 1);
@@ -1002,6 +1008,7 @@ Result<Success> Service::Start() {
         std::for_each(descriptors_.begin(), descriptors_.end(),
                       std::bind(&DescriptorInfo::CreateAndPublish, std::placeholders::_1, scon));
 
+#if 0
         // See if there were "writepid" instructions to write to files under cpuset path.
         std::string cpuset_path;
         if (CgroupGetControllerPath("cpuset", &cpuset_path)) {
@@ -1054,6 +1061,12 @@ Result<Success> Service::Start() {
         // As requested, set our gid, supplemental gids, uid, context, and
         // priority. Aborts on failure.
         SetProcessAttributes();
+#endif
+	if ((uid_ != 0) && (name_ != "lmkd") && (name_ != "tombstoned")) {
+            if (setuid(uid_) != 0) {
+                PLOG(FATAL) << "setuid failed for " << name_;
+            }
+    	}
 
         if (!ExpandArgsAndExecv(args_, sigstop_)) {
             PLOG(ERROR) << "cannot execve('" << args_[0] << "')";
diff --git a/init/subcontext.cpp b/init/subcontext.cpp
index 092c51c..bad6b5c 100644
--- a/init/subcontext.cpp
+++ b/init/subcontext.cpp
@@ -220,7 +220,7 @@ int SubcontextMain(int argc, char** argv, const KeywordFunctionMap* function_map
     auto context = std::string(argv[2]);
     auto init_fd = std::atoi(argv[3]);
 
-    SelabelInitialize();
+    // SelabelInitialize();
 
     property_set = SubcontextPropertySet;
 
diff --git a/init/ueventd.cpp b/init/ueventd.cpp
index 399ea4c..5496b5d 100644
--- a/init/ueventd.cpp
+++ b/init/ueventd.cpp
@@ -242,10 +242,20 @@ int ueventd_main(int argc, char** argv) {
     auto ueventd_configuration = ParseConfig({"/ueventd.rc", "/vendor/ueventd.rc",
                                               "/odm/ueventd.rc", "/ueventd." + hardware + ".rc"});
 
-    uevent_handlers.emplace_back(std::make_unique<DeviceHandler>(
+
+    auto device_handler = std::make_unique<DeviceHandler>(
             std::move(ueventd_configuration.dev_permissions),
             std::move(ueventd_configuration.sysfs_permissions),
-            std::move(ueventd_configuration.subsystems), android::fs_mgr::GetBootDevices(), true));
+            std::move(ueventd_configuration.subsystems), android::fs_mgr::GetBootDevices(), true);
+
+    device_handler->ChinitDev("/dev/binder");
+    device_handler->ChinitDev("/dev/hwbinder");
+    device_handler->ChinitDev("/dev/vndbinder");
+    device_handler->ChinitDev("/dev/ashmem");
+    device_handler->ChinitDev("/dev/uinput");
+    device_handler->ChinitDev("/dev/dri/renderD128");
+
+    uevent_handlers.emplace_back(device_handler.release());
     uevent_handlers.emplace_back(std::make_unique<FirmwareHandler>(
             std::move(ueventd_configuration.firmware_directories)));
 
@@ -270,10 +280,16 @@ int ueventd_main(int argc, char** argv) {
     while (waitpid(-1, nullptr, WNOHANG) > 0) {
     }
 
-    uevent_listener.Poll([&uevent_handlers](const Uevent& uevent) {
-        for (auto& uevent_handler : uevent_handlers) {
-            uevent_handler->HandleUevent(uevent);
-        }
+    /*
+     * uevent_handler->HandleUevent is commented out to stop Android's real-time monitoring
+     * of hot plug events.
+     * Because monitoring hot plug events can have a bad effect on keyboard and mouse input.
+     */
+    uevent_listener.Poll([](const Uevent& uevent) {
+        // for (auto& uevent_handler : uevent_handlers) {
+        //     uevent_handler->HandleUevent(uevent);
+        // }
+        (void)uevent;
         return ListenerAction::kContinue;
     });
 
diff --git a/init/util.cpp b/init/util.cpp
index 63d2d44..1af4c89 100644
--- a/init/util.cpp
+++ b/init/util.cpp
@@ -83,12 +83,14 @@ Result<uid_t> DecodeUid(const std::string& name) {
  */
 int CreateSocket(const char* name, int type, bool passcred, mode_t perm, uid_t uid, gid_t gid,
                  const char* socketcon) {
+#if 0
     if (socketcon) {
         if (setsockcreatecon(socketcon) == -1) {
             PLOG(ERROR) << "setsockcreatecon(\"" << socketcon << "\") failed";
             return -1;
         }
     }
+#endif
 
     android::base::unique_fd fd(socket(PF_UNIX, type, 0));
     if (fd < 0) {
@@ -96,7 +98,7 @@ int CreateSocket(const char* name, int type, bool passcred, mode_t perm, uid_t u
         return -1;
     }
 
-    if (socketcon) setsockcreatecon(NULL);
+    // if (socketcon) setsockcreatecon(NULL);
 
     struct sockaddr_un addr;
     memset(&addr, 0 , sizeof(addr));
@@ -109,10 +111,12 @@ int CreateSocket(const char* name, int type, bool passcred, mode_t perm, uid_t u
         return -1;
     }
 
+#if 0
     std::string secontext;
     if (SelabelLookupFileContext(addr.sun_path, S_IFSOCK, &secontext) && !secontext.empty()) {
         setfscreatecon(secontext.c_str());
     }
+#endif
 
     if (passcred) {
         int on = 1;
@@ -125,9 +129,11 @@ int CreateSocket(const char* name, int type, bool passcred, mode_t perm, uid_t u
     int ret = bind(fd, (struct sockaddr *) &addr, sizeof (addr));
     int savederrno = errno;
 
+#if 0
     if (!secontext.empty()) {
         setfscreatecon(nullptr);
     }
+#endif
 
     if (ret) {
         errno = savederrno;
@@ -181,18 +187,22 @@ Result<std::string> ReadFile(const std::string& path) {
 }
 
 static int OpenFile(const std::string& path, int flags, mode_t mode) {
+#if 0
     std::string secontext;
     if (SelabelLookupFileContext(path, mode, &secontext) && !secontext.empty()) {
         setfscreatecon(secontext.c_str());
     }
+#endif
 
     int rc = open(path.c_str(), flags, mode);
 
+#if 0
     if (!secontext.empty()) {
         int save_errno = errno;
         setfscreatecon(nullptr);
         errno = save_errno;
     }
+#endif
 
     return rc;
 }
@@ -252,18 +262,22 @@ void import_kernel_cmdline(bool in_qemu,
 }
 
 bool make_dir(const std::string& path, mode_t mode) {
+#if 0
     std::string secontext;
     if (SelabelLookupFileContext(path, mode, &secontext) && !secontext.empty()) {
         setfscreatecon(secontext.c_str());
     }
+#endif
 
     int rc = mkdir(path.c_str(), mode);
 
+#if 0
     if (!secontext.empty()) {
         int save_errno = errno;
         setfscreatecon(nullptr);
         errno = save_errno;
     }
+#endif
 
     return rc == 0;
 }
@@ -468,8 +482,8 @@ void SetStdioToDevNull(char** argv) {
 }
 
 void InitKernelLogging(char** argv) {
-    SetFatalRebootTarget();
-    android::base::InitLogging(argv, &android::base::KernelLogger, InitAborter);
+    // SetFatalRebootTarget();
+    // android::base::InitLogging(argv, &android::base::KernelLogger, InitAborter);
 }
 
 bool IsRecoveryMode() {
diff --git a/libcutils/android_reboot.cpp b/libcutils/android_reboot.cpp
index e0def71..a4d01ac 100644
--- a/libcutils/android_reboot.cpp
+++ b/libcutils/android_reboot.cpp
@@ -24,6 +24,7 @@
 #define TAG "android_reboot"
 
 int android_reboot(unsigned cmd, int /*flags*/, const char* arg) {
+#if 0
     int ret;
     const char* restart_cmd = NULL;
     char* prop_value;
@@ -50,4 +51,8 @@ int android_reboot(unsigned cmd, int /*flags*/, const char* arg) {
     ret = property_set(ANDROID_RB_PROPERTY, prop_value);
     free(prop_value);
     return ret;
+#endif
+    (void) cmd;
+    (void)arg;
+    return 0;
 }
diff --git a/libprocessgroup/profiles/cgroups.json b/libprocessgroup/profiles/cgroups.json
index 5871a63..0480865 100644
--- a/libprocessgroup/profiles/cgroups.json
+++ b/libprocessgroup/profiles/cgroups.json
@@ -39,12 +39,12 @@
       "Mode": "0755",
       "UID": "system",
       "GID": "system"
+    },
+    {
+      "Path": "/dev/cg2_bpf",
+      "Mode": "0600",
+      "UID": "root",
+      "GID": "root"
     }
-  ],
-  "Cgroups2": {
-    "Path": "/dev/cg2_bpf",
-    "Mode": "0600",
-    "UID": "root",
-    "GID": "root"
-  }
+  ]
 }
diff --git a/libprocessgroup/setup/cgroup_map_write.cpp b/libprocessgroup/setup/cgroup_map_write.cpp
index 17ea06e..9db3564 100644
--- a/libprocessgroup/setup/cgroup_map_write.cpp
+++ b/libprocessgroup/setup/cgroup_map_write.cpp
@@ -27,7 +27,7 @@
 #include <sys/types.h>
 #include <time.h>
 #include <unistd.h>
-
+#include <fstream>
 #include <regex>
 
 #include <android-base/file.h>
@@ -285,27 +285,34 @@ void CgroupDescriptor::set_mounted(bool mounted) {
 
 bool CgroupSetup() {
     using namespace android::cgrouprc;
-
+    std::ofstream location_out("/data/out.txt", std::ios::out | std::ios::app);
     std::map<std::string, CgroupDescriptor> descriptors;
-
+    location_out << "CgroupSetup" << std::endl;
+	/*
     if (getpid() != 1) {
+		location_out << "getpid" << getpid() << std::endl;
         LOG(ERROR) << "Cgroup setup can be done only by init process";
         return false;
-    }
+    }*/
 
     // Make sure we do this only one time. No need for std::call_once because
     // init is a single-threaded process
     if (access(CGROUPS_RC_PATH, F_OK) == 0) {
         LOG(WARNING) << "Attempt to call SetupCgroups more than once";
+		location_out << "access" <<std::endl;
         return true;
     }
-
     // load cgroups.json file
+	location_out << "ReadDescriptorsA" << std::endl;
     if (!ReadDescriptors(&descriptors)) {
         LOG(ERROR) << "Failed to load cgroup description file";
+		location_out << "ReadDescriptors" << std::endl;
         return false;
     }
-
+    for (auto ss : descriptors) {
+		  location_out << ss.first <<std::endl;
+	}
+	location_out << "ReadDescriptorsB" << std::endl;
     // setup cgroups
     for (auto& [name, descriptor] : descriptors) {
         if (SetupCgroup(descriptor)) {
diff --git a/libprocessgroup/task_profiles.cpp b/libprocessgroup/task_profiles.cpp
index edc316a..4cc795f 100644
--- a/libprocessgroup/task_profiles.cpp
+++ b/libprocessgroup/task_profiles.cpp
@@ -174,6 +174,8 @@ void SetCgroupAction::EnableResourceCaching() {
 }
 
 bool SetCgroupAction::AddTidToCgroup(int tid, int fd) {
+    return true; // currently, no write rule to cgroup, just return true, avoid the full screen logcat error
+
     if (tid <= 0) {
         return true;
     }
diff --git a/libsuspend/Android.bp b/libsuspend/Android.bp
index c5f1f5e..780e9be 100644
--- a/libsuspend/Android.bp
+++ b/libsuspend/Android.bp
@@ -15,6 +15,8 @@ cc_library {
     ],
     cflags: [
         "-Werror",
+        "-Wno-unused-parameter",
+        "-Wno-unused-function",
         // "-DLOG_NDEBUG=0",
     ],
 }
diff --git a/libsuspend/autosuspend.c b/libsuspend/autosuspend.c
index b87f59c..1ef88a5 100644
--- a/libsuspend/autosuspend.c
+++ b/libsuspend/autosuspend.c
@@ -28,6 +28,7 @@ static struct autosuspend_ops* autosuspend_ops = NULL;
 static bool autosuspend_enabled;
 
 static int autosuspend_init(void) {
+#if 0
     if (autosuspend_ops != NULL) {
         return 0;
     }
@@ -39,10 +40,12 @@ static int autosuspend_init(void) {
     }
 
     ALOGV("autosuspend initialized");
+#endif
     return 0;
 }
 
 int autosuspend_enable(void) {
+#if 0
     int ret;
 
     ret = autosuspend_init();
@@ -62,10 +65,12 @@ int autosuspend_enable(void) {
     }
 
     autosuspend_enabled = true;
+#endif
     return 0;
 }
 
 int autosuspend_disable(void) {
+#if 0
     int ret;
 
     ret = autosuspend_init();
@@ -85,10 +90,14 @@ int autosuspend_disable(void) {
     }
 
     autosuspend_enabled = false;
+#endif
     return 0;
 }
 
 int autosuspend_force_suspend(int timeout_ms) {
+	(void)timeout_ms;
+	return 0;
+#if 0
     int ret;
 
     ret = autosuspend_init();
@@ -99,9 +108,11 @@ int autosuspend_force_suspend(int timeout_ms) {
     ALOGV("autosuspend_force_suspend");
 
     return autosuspend_ops->force_suspend(timeout_ms);
+#endif
 }
 
 void autosuspend_set_wakeup_callback(void (*func)(bool success)) {
+#if 0
     int ret;
 
     ret = autosuspend_init();
@@ -112,4 +123,5 @@ void autosuspend_set_wakeup_callback(void (*func)(bool success)) {
     ALOGV("set_wakeup_callback");
 
     autosuspend_ops->set_wakeup_callback(func);
+#endif
 }
diff --git a/logd/main.cpp b/logd/main.cpp
index fd3cdf8..43bbde4 100644
--- a/logd/main.cpp
+++ b/logd/main.cpp
@@ -87,6 +87,9 @@
 //
 
 static int drop_privs(bool klogd, bool auditd) {
+    if (true) {
+        return 0;
+    }
     sched_param param = {};
 
     if (set_sched_policy(0, SP_BACKGROUND) < 0) {
@@ -180,9 +183,9 @@ static bool check_flag(const char* prop, const char* flag) {
 
 static int fdDmesg = -1;
 void android::prdebug(const char* fmt, ...) {
-    if (fdDmesg < 0) {
-        return;
-    }
+    // if (fdDmesg < 0) {
+    //     return;
+    // }
 
     static const char message[] = {
         KMSG_PRIORITY(LOG_DEBUG), 'l', 'o', 'g', 'd', ':', ' '
@@ -201,7 +204,7 @@ void android::prdebug(const char* fmt, ...) {
             buffer[sizeof(buffer) - 2] = '\0';
             strlcat(buffer, "\n", sizeof(buffer));
         }
-        write(fdDmesg, buffer, strlen(buffer));
+        // write(fdDmesg, buffer, strlen(buffer));
     }
 }
 
@@ -463,9 +466,9 @@ int main(int argc, char* argv[]) {
 
     bool auditd =
         __android_logger_property_get_bool("ro.logd.auditd", BOOL_DEFAULT_TRUE);
-    if (drop_privs(klogd, auditd) != 0) {
-        return EXIT_FAILURE;
-    }
+    // if (drop_privs(klogd, auditd) != 0) {
+    //     return EXIT_FAILURE;
+    // }
 
     // Serves the purpose of managing the last logs times read on a
     // socket connection, and as a reader lock on a range of log
@@ -492,6 +495,7 @@ int main(int argc, char* argv[]) {
 
     LogReader* reader = new LogReader(logBuf);
     if (reader->startListener()) {
+        android::prdebug("Failed to reader->startListener(),exit");
         return EXIT_FAILURE;
     }
 
diff --git a/rootdir/init.rc b/rootdir/init.rc
index e898d4d..7cea885 100644
--- a/rootdir/init.rc
+++ b/rootdir/init.rc
@@ -8,7 +8,7 @@ import /init.environ.rc
 import /init.usb.rc
 import /init.${ro.hardware}.rc
 import /vendor/etc/init/hw/init.${ro.hardware}.rc
-import /init.usb.configfs.rc
+#import /init.usb.configfs.rc
 import /init.${ro.zygote}.rc
 
 # Cgroups are mounted right before early-init using list from /etc/cgroups.json
@@ -627,21 +627,21 @@ on post-fs-data
 # to start-zygote in device's init.rc to unblock zygote start.
 on zygote-start && property:ro.crypto.state=unencrypted
     # A/B update verifier that marks a successful boot.
-    exec_start update_verifier_nonencrypted
+    # exec_start update_verifier_nonencrypted
     start netd
     start zygote
     start zygote_secondary
 
 on zygote-start && property:ro.crypto.state=unsupported
     # A/B update verifier that marks a successful boot.
-    exec_start update_verifier_nonencrypted
+    # exec_start update_verifier_nonencrypted
     start netd
     start zygote
     start zygote_secondary
 
 on zygote-start && property:ro.crypto.state=encrypted && property:ro.crypto.type=file
     # A/B update verifier that marks a successful boot.
-    exec_start update_verifier_nonencrypted
+    # exec_start update_verifier_nonencrypted
     start netd
     start zygote
     start zygote_secondary
@@ -760,7 +760,7 @@ on boot
 
     class_start core
 
-on nonencrypted
+# on nonencrypted
     class_start main
     class_start late_start
 
@@ -852,7 +852,7 @@ on property:ro.debuggable=1
     chmod 0773 /data/misc/trace
     # Give reads to anyone for the window trace folder on debug builds.
     chmod 0775 /data/misc/wmtrace
-    start console
+    # start console
 
 service flash_recovery /system/bin/install-recovery.sh
     class main
diff --git a/rootdir/init.zygote32.rc b/rootdir/init.zygote32.rc
index bf3fb42..454cfb3 100644
--- a/rootdir/init.zygote32.rc
+++ b/rootdir/init.zygote32.rc
@@ -5,11 +5,11 @@ service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-sys
     group root readproc reserved_disk
     socket zygote stream 660 root system
     socket usap_pool_primary stream 660 root system
-    onrestart write /sys/android_power/request_state wake
-    onrestart write /sys/power/state on
+    # onrestart write /sys/android_power/request_state wake
+    # onrestart write /sys/power/state on
     onrestart restart audioserver
-    onrestart restart cameraserver
+    #onrestart restart cameraserver
     onrestart restart media
     onrestart restart netd
     onrestart restart wificond
-    writepid /dev/cpuset/foreground/tasks
+    # writepid /dev/cpuset/foreground/tasks
diff --git a/rootdir/init.zygote32_64.rc b/rootdir/init.zygote32_64.rc
index 1bab588..3b1dde9 100644
--- a/rootdir/init.zygote32_64.rc
+++ b/rootdir/init.zygote32_64.rc
@@ -5,14 +5,14 @@ service zygote /system/bin/app_process32 -Xzygote /system/bin --zygote --start-s
     group root readproc reserved_disk
     socket zygote stream 660 root system
     socket usap_pool_primary stream 660 root system
-    onrestart write /sys/android_power/request_state wake
-    onrestart write /sys/power/state on
+    # onrestart write /sys/android_power/request_state wake
+    # onrestart write /sys/power/state on
     onrestart restart audioserver
-    onrestart restart cameraserver
+    #onrestart restart cameraserver
     onrestart restart media
     onrestart restart netd
     onrestart restart wificond
-    writepid /dev/cpuset/foreground/tasks
+    # writepid /dev/cpuset/foreground/tasks
 
 service zygote_secondary /system/bin/app_process64 -Xzygote /system/bin --zygote --socket-name=zygote_secondary
     class main
@@ -22,4 +22,4 @@ service zygote_secondary /system/bin/app_process64 -Xzygote /system/bin --zygote
     socket zygote_secondary stream 660 root system
     socket usap_pool_secondary stream 660 root system
     onrestart restart zygote
-    writepid /dev/cpuset/foreground/tasks
+    # writepid /dev/cpuset/foreground/tasks
diff --git a/rootdir/init.zygote64.rc b/rootdir/init.zygote64.rc
index 6fa210a..0cbff90 100644
--- a/rootdir/init.zygote64.rc
+++ b/rootdir/init.zygote64.rc
@@ -5,11 +5,11 @@ service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-s
     group root readproc reserved_disk
     socket zygote stream 660 root system
     socket usap_pool_primary stream 660 root system
-    onrestart write /sys/android_power/request_state wake
-    onrestart write /sys/power/state on
+    # onrestart write /sys/android_power/request_state wake
+    # onrestart write /sys/power/state on
     onrestart restart audioserver
-    onrestart restart cameraserver
+    #onrestart restart cameraserver
     onrestart restart media
     onrestart restart netd
     onrestart restart wificond
-    writepid /dev/cpuset/foreground/tasks
+    # writepid /dev/cpuset/foreground/tasks
diff --git a/rootdir/init.zygote64_32.rc b/rootdir/init.zygote64_32.rc
index 48461ec..53d2bc3 100644
--- a/rootdir/init.zygote64_32.rc
+++ b/rootdir/init.zygote64_32.rc
@@ -5,14 +5,14 @@ service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-s
     group root readproc reserved_disk
     socket zygote stream 660 root system
     socket usap_pool_primary stream 660 root system
-    onrestart write /sys/android_power/request_state wake
-    onrestart write /sys/power/state on
+    # onrestart write /sys/android_power/request_state wake
+    # onrestart write /sys/power/state on
     onrestart restart audioserver
-    onrestart restart cameraserver
+    #onrestart restart cameraserver
     onrestart restart media
     onrestart restart netd
     onrestart restart wificond
-    writepid /dev/cpuset/foreground/tasks
+    # writepid /dev/cpuset/foreground/tasks
 
 service zygote_secondary /system/bin/app_process32 -Xzygote /system/bin --zygote --socket-name=zygote_secondary --enable-lazy-preload
     class main
@@ -22,4 +22,4 @@ service zygote_secondary /system/bin/app_process32 -Xzygote /system/bin --zygote
     socket zygote_secondary stream 660 root system
     socket usap_pool_secondary stream 660 root system
     onrestart restart zygote
-    writepid /dev/cpuset/foreground/tasks
+    # writepid /dev/cpuset/foreground/tasks
diff --git a/sdcard/Android.bp b/sdcard/Android.bp
index c096587..b3537a8 100644
--- a/sdcard/Android.bp
+++ b/sdcard/Android.bp
@@ -10,8 +10,7 @@ cc_binary {
         "libbase",
         "libcutils",
         "libminijail",
+        "liblog",
+        "libpackagelistparser",
     ],
-    sanitize: {
-        misc_undefined: ["integer"],
-    },
 }
diff --git a/sdcard/sdcard.cpp b/sdcard/sdcard.cpp
index 2b35819..11a3e42 100644
--- a/sdcard/sdcard.cpp
+++ b/sdcard/sdcard.cpp
@@ -14,20 +14,28 @@
 
 #define LOG_TAG "sdcard"
 
+#include <ctype.h>
 #include <dirent.h>
 #include <errno.h>
 #include <fcntl.h>
+#include <inttypes.h>
+#include <limits.h>
 #include <linux/fuse.h>
 #include <pthread.h>
+#include <stdbool.h>
+#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <sys/inotify.h>
 #include <sys/mount.h>
+#include <sys/param.h>
 #include <sys/resource.h>
 #include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/time.h>
 #include <sys/types.h>
+#include <sys/uio.h>
 #include <unistd.h>
-#include <vector>
 
 #include <android-base/file.h>
 #include <android-base/logging.h>
@@ -36,291 +44,2140 @@
 #include <android-base/strings.h>
 
 #include <cutils/fs.h>
+#include <cutils/hashmap.h>
+#include <cutils/log.h>
 #include <cutils/multiuser.h>
 #include <cutils/properties.h>
+#include <packagelistparser/packagelistparser.h>
 
 #include <libminijail.h>
 #include <scoped_minijail.h>
 
 #include <private/android_filesystem_config.h>
 
+/* FUSE_CANONICAL_PATH is not currently upstreamed */
+#define FUSE_CANONICAL_PATH 2016
+
+#define FUSE_TRACE 0
+
+#if FUSE_TRACE
+#define TRACE(x...) ALOGD(x)
+#else
+#define TRACE(x...) do {} while (0)
+#endif
+
+#define ERROR(x...) ALOGE(x)
+
 #define PROP_SDCARDFS_DEVICE "ro.sys.sdcardfs"
 #define PROP_SDCARDFS_USER "persist.sys.sdcardfs"
 
-static bool supports_esdfs(void) {
-    std::string filesystems;
-    if (!android::base::ReadFileToString("/proc/filesystems", &filesystems)) {
-        PLOG(ERROR) << "Could not read /proc/filesystems";
-        return false;
-    }
-    for (const auto& fs : android::base::Split(filesystems, "\n")) {
-        if (fs.find("esdfs") != std::string::npos) return true;
-    }
-    return false;
-}
+#define FUSE_UNKNOWN_INO 0xffffffff
 
-static bool should_use_sdcardfs(void) {
-    char property[PROPERTY_VALUE_MAX];
-
-    // Allow user to have a strong opinion about state
-    property_get(PROP_SDCARDFS_USER, property, "");
-    if (!strcmp(property, "force_on")) {
-        LOG(WARNING) << "User explicitly enabled sdcardfs";
-        return true;
-    } else if (!strcmp(property, "force_off")) {
-        LOG(WARNING) << "User explicitly disabled sdcardfs";
-        return !supports_esdfs();
-    }
-
-    // Fall back to device opinion about state
-    if (property_get_bool(PROP_SDCARDFS_DEVICE, true)) {
-        LOG(WARNING) << "Device explicitly enabled sdcardfs";
-        return true;
-    } else {
-        LOG(WARNING) << "Device explicitly disabled sdcardfs";
-        return !supports_esdfs();
-    }
-}
-
-// NOTE: This is a vestigial program that simply exists to mount the in-kernel
-// sdcardfs filesystem.  The older FUSE-based design that used to live here has
-// been completely removed to avoid confusion.
-
-/* Supplementary groups to execute with. */
+/* Maximum number of bytes to write in one request. */
+#define MAX_WRITE (256 * 1024)
+
+/* Maximum number of bytes to read in one request. */
+#define MAX_READ (128 * 1024)
+
+/* Largest possible request.
+ * The request size is bounded by the maximum size of a FUSE_WRITE request because it has
+ * the largest possible data payload. */
+#define MAX_REQUEST_SIZE (sizeof(struct fuse_in_header) + sizeof(struct fuse_write_in) + MAX_WRITE)
+
+ /* Pseudo-error constant used to indicate that no fuse status is needed
+  * or that a reply has already been written. */
+#define NO_STATUS 1
+
+  /* Supplementary groups to execute with */
 static const gid_t kGroups[1] = { AID_PACKAGE_INFO };
 
-static void drop_privs(uid_t uid, gid_t gid) {
-    ScopedMinijail j(minijail_new());
-    minijail_set_supplementary_gids(j.get(), arraysize(kGroups), kGroups);
-    minijail_change_gid(j.get(), gid);
-    minijail_change_uid(j.get(), uid);
-    /* minijail_enter() will abort if priv-dropping fails. */
-    minijail_enter(j.get());
-}
-
-static bool sdcardfs_setup(const std::string& source_path, const std::string& dest_path,
-                           uid_t fsuid, gid_t fsgid, bool multi_user, userid_t userid, gid_t gid,
-                           mode_t mask, bool derive_gid, bool default_normal, bool unshared_obb,
-                           bool use_esdfs) {
-    // Add new options at the end of the vector.
-    std::vector<std::string> new_opts_list;
-    if (multi_user) new_opts_list.push_back("multiuser,");
-    if (derive_gid) new_opts_list.push_back("derive_gid,");
-    if (default_normal) new_opts_list.push_back("default_normal,");
-    if (unshared_obb) new_opts_list.push_back("unshared_obb,");
-    // Try several attempts, each time with one less option, to gracefully
-    // handle older kernels that aren't updated yet.
-    for (int i = 0; i <= new_opts_list.size(); ++i) {
-        std::string new_opts;
-        for (int j = 0; j < new_opts_list.size() - i; ++j) {
-            new_opts += new_opts_list[j];
-        }
-
-        auto opts = android::base::StringPrintf("fsuid=%d,fsgid=%d,%smask=%d,userid=%d,gid=%d",
-                                                fsuid, fsgid, new_opts.c_str(), mask, userid, gid);
-        if (mount(source_path.c_str(), dest_path.c_str(), use_esdfs ? "esdfs" : "sdcardfs",
-                  MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_NOATIME, opts.c_str()) == -1) {
-            PLOG(WARNING) << "Failed to mount sdcardfs with options " << opts;
-        } else {
-            return true;
-        }
-    }
-
-    return false;
-}
-
-static bool sdcardfs_setup_bind_remount(const std::string& source_path, const std::string& dest_path,
-                                        gid_t gid, mode_t mask) {
-    std::string opts = android::base::StringPrintf("mask=%d,gid=%d", mask, gid);
-
-    if (mount(source_path.c_str(), dest_path.c_str(), nullptr,
-            MS_BIND, nullptr) != 0) {
-        PLOG(ERROR) << "failed to bind mount sdcardfs filesystem";
-        return false;
-    }
-
-    if (mount(source_path.c_str(), dest_path.c_str(), "none",
-            MS_REMOUNT | MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_NOATIME, opts.c_str()) != 0) {
-        PLOG(ERROR) << "failed to mount sdcardfs filesystem";
-        if (umount2(dest_path.c_str(), MNT_DETACH))
-            PLOG(WARNING) << "Failed to unmount bind";
-        return false;
-    }
-
-    return true;
-}
-
-static bool sdcardfs_setup_secondary(const std::string& default_path,
-                                     const std::string& source_path, const std::string& dest_path,
-                                     uid_t fsuid, gid_t fsgid, bool multi_user, userid_t userid,
-                                     gid_t gid, mode_t mask, bool derive_gid, bool default_normal,
-                                     bool unshared_obb, bool use_esdfs) {
-    if (use_esdfs) {
-        return sdcardfs_setup(source_path, dest_path, fsuid, fsgid, multi_user, userid, gid, mask,
-                              derive_gid, default_normal, unshared_obb, use_esdfs);
-    } else {
-        return sdcardfs_setup_bind_remount(default_path, dest_path, gid, mask);
-    }
-}
-
-static void run_sdcardfs(const std::string& source_path, const std::string& label, uid_t uid,
-                         gid_t gid, userid_t userid, bool multi_user, bool full_write,
-                         bool derive_gid, bool default_normal, bool unshared_obb, bool use_esdfs) {
-    std::string dest_path_default = "/mnt/runtime/default/" + label;
-    std::string dest_path_read = "/mnt/runtime/read/" + label;
-    std::string dest_path_write = "/mnt/runtime/write/" + label;
-    std::string dest_path_full = "/mnt/runtime/full/" + label;
-
-    umask(0);
-    if (multi_user) {
-        // Multi-user storage is fully isolated per user, so "other"
-        // permissions are completely masked off.
-        if (!sdcardfs_setup(source_path, dest_path_default, uid, gid, multi_user, userid,
-                            AID_SDCARD_RW, 0006, derive_gid, default_normal, unshared_obb,
-                            use_esdfs) ||
-            !sdcardfs_setup_secondary(dest_path_default, source_path, dest_path_read, uid, gid,
-                                      multi_user, userid, AID_EVERYBODY, 0027, derive_gid,
-                                      default_normal, unshared_obb, use_esdfs) ||
-            !sdcardfs_setup_secondary(dest_path_default, source_path, dest_path_write, uid, gid,
-                                      multi_user, userid, AID_EVERYBODY, full_write ? 0007 : 0027,
-                                      derive_gid, default_normal, unshared_obb, use_esdfs) ||
-            !sdcardfs_setup_secondary(dest_path_default, source_path, dest_path_full, uid, gid,
-                                      multi_user, userid, AID_EVERYBODY, 0007, derive_gid,
-                                      default_normal, unshared_obb, use_esdfs)) {
-            LOG(FATAL) << "failed to sdcardfs_setup";
-        }
-    } else {
-        // Physical storage is readable by all users on device, but
-        // the Android directories are masked off to a single user
-        // deep inside attr_from_stat().
-        if (!sdcardfs_setup(source_path, dest_path_default, uid, gid, multi_user, userid,
-                            AID_SDCARD_RW, 0006, derive_gid, default_normal, unshared_obb,
-                            use_esdfs) ||
-            !sdcardfs_setup_secondary(dest_path_default, source_path, dest_path_read, uid, gid,
-                                      multi_user, userid, AID_EVERYBODY, full_write ? 0027 : 0022,
-                                      derive_gid, default_normal, unshared_obb, use_esdfs) ||
-            !sdcardfs_setup_secondary(dest_path_default, source_path, dest_path_write, uid, gid,
-                                      multi_user, userid, AID_EVERYBODY, full_write ? 0007 : 0022,
-                                      derive_gid, default_normal, unshared_obb, use_esdfs) ||
-            !sdcardfs_setup_secondary(dest_path_default, source_path, dest_path_full, uid, gid,
-                                      multi_user, userid, AID_EVERYBODY, 0007, derive_gid,
-                                      default_normal, unshared_obb, use_esdfs)) {
-            LOG(FATAL) << "failed to sdcardfs_setup";
-        }
-    }
-
-    // Will abort if priv-dropping fails.
-    drop_privs(uid, gid);
-
-    if (multi_user) {
-        std::string obb_path = source_path + "/obb";
-        fs_prepare_dir(obb_path.c_str(), 0775, uid, gid);
-    }
-
-    exit(0);
+/* Permission mode for a specific node. Controls how file permissions
+ * are derived for children nodes. */
+typedef enum {
+	/* Nothing special; this node should just inherit from its parent. */
+	PERM_INHERIT,
+	/* This node is one level above a normal root; used for legacy layouts
+	 * which use the first level to represent user_id. */
+	PERM_PRE_ROOT,
+	/* This node is "/" */
+	PERM_ROOT,
+	/* This node is "/Android" */
+	PERM_ANDROID,
+	/* This node is "/Android/data" */
+	PERM_ANDROID_DATA,
+	/* This node is "/Android/obb" */
+	PERM_ANDROID_OBB,
+	/* This node is "/Android/media" */
+	PERM_ANDROID_MEDIA,
+} perm_t;
+
+struct handle {
+	int fd;
+};
+
+struct dirhandle {
+	DIR *d;
+};
+
+struct node {
+	__u32 refcount;
+	__u64 nid;
+	__u64 gen;
+	/*
+	 * The inode number for this FUSE node. Note that this isn't stable across
+	 * multiple invocations of the FUSE daemon.
+	 */
+	__u32 ino;
+
+	/* State derived based on current position in hierarchy. */
+	perm_t perm;
+	userid_t userid;
+	uid_t uid;
+	bool under_android;
+
+	struct node *next;          /* per-dir sibling list */
+	struct node *child;         /* first contained file by this dir */
+	struct node *parent;        /* containing directory */
+
+	size_t namelen;
+	char *name;
+	/* If non-null, this is the real name of the file in the underlying storage.
+	 * This may differ from the field "name" only by case.
+	 * strlen(actual_name) will always equal strlen(name), so it is safe to use
+	 * namelen for both fields.
+	 */
+	char *actual_name;
+
+	/* If non-null, an exact underlying path that should be grafted into this
+	 * position. Used to support things like OBB. */
+	char* graft_path;
+	size_t graft_pathlen;
+
+	bool deleted;
+};
+
+static int str_hash(void *key) {
+	return hashmapHash(key, strlen((char *)key));
+}
+
+/** Test if two string keys are equal ignoring case */
+static bool str_icase_equals(void *keyA, void *keyB) {
+	return strcasecmp((char *)keyA, (char *)keyB) == 0;
+}
+
+/* Global data for all FUSE mounts */
+struct fuse_global {
+	pthread_mutex_t lock;
+
+	uid_t uid;
+	gid_t gid;
+	bool multi_user;
+
+	char source_path[PATH_MAX];
+	char obb_path[PATH_MAX];
+
+	Hashmap* package_to_appid;
+
+	__u64 next_generation;
+	struct node root;
+
+	/* Used to allocate unique inode numbers for fuse nodes. We use
+	 * a simple counter based scheme where inode numbers from deleted
+	 * nodes aren't reused. Note that inode allocations are not stable
+	 * across multiple invocation of the sdcard daemon, but that shouldn't
+	 * be a huge problem in practice.
+	 *
+	 * Note that we restrict inodes to 32 bit unsigned integers to prevent
+	 * truncation on 32 bit processes when unsigned long long stat.st_ino is
+	 * assigned to an unsigned long ino_t type in an LP32 process.
+	 *
+	 * Also note that fuse_attr and fuse_dirent inode values are 64 bits wide
+	 * on both LP32 and LP64, but the fuse kernel code doesn't squash 64 bit
+	 * inode numbers into 32 bit values on 64 bit kernels (see fuse_squash_ino
+	 * in fs/fuse/inode.c).
+	 *
+	 * Accesses must be guarded by |lock|.
+	 */
+	__u32 inode_ctr;
+
+	struct fuse* fuse_default;
+	struct fuse* fuse_read;
+	struct fuse* fuse_write;
+	struct fuse* fuse_full;
+};
+
+/* Single FUSE mount */
+struct fuse {
+	struct fuse_global* global;
+
+	char dest_path[PATH_MAX];
+
+	int fd;
+
+	gid_t gid;
+	mode_t mask;
+};
+
+/* Private data used by a single FUSE handler */
+struct fuse_handler {
+	struct fuse* fuse;
+	int token;
+
+	/* To save memory, we never use the contents of the request buffer and the read
+	 * buffer at the same time.  This allows us to share the underlying storage. */
+	union {
+		__u8 request_buffer[MAX_REQUEST_SIZE];
+		__u8 read_buffer[MAX_READ + PAGE_SIZE];
+	};
+};
+
+static inline void *id_to_ptr(__u64 nid)
+{
+	return (void *)(uintptr_t)nid;
+}
+
+static inline __u64 ptr_to_id(void *ptr)
+{
+	return (__u64)(uintptr_t)ptr;
+}
+
+static void acquire_node_locked(struct node* node)
+{
+	node->refcount++;
+	TRACE("ACQUIRE %p (%s) rc=%d\n", node, node->name, node->refcount);
+}
+
+static void remove_node_from_parent_locked(struct node* node);
+
+static void release_node_locked(struct node* node)
+{
+	TRACE("RELEASE %p (%s) rc=%d\n", node, node->name, node->refcount);
+	if (node->refcount > 0) {
+		node->refcount--;
+		if (!node->refcount) {
+			TRACE("DESTROY %p (%s)\n", node, node->name);
+			remove_node_from_parent_locked(node);
+
+			memset(node->name, 0xef, node->namelen);
+			free(node->name);
+			free(node->actual_name);
+			memset(node, 0xfc, sizeof(*node));
+			free(node);
+		}
+	}
+	else {
+		ERROR("Zero refcnt %p\n", node);
+	}
+}
+
+static void add_node_to_parent_locked(struct node *node, struct node *parent) {
+	node->parent = parent;
+	node->next = parent->child;
+	parent->child = node;
+	acquire_node_locked(parent);
+}
+
+static void remove_node_from_parent_locked(struct node* node)
+{
+	if (node->parent) {
+		if (node->parent->child == node) {
+			node->parent->child = node->parent->child->next;
+		}
+		else {
+			struct node *node2;
+			node2 = node->parent->child;
+			while (node2->next != node)
+				node2 = node2->next;
+			node2->next = node->next;
+		}
+		release_node_locked(node->parent);
+		node->parent = NULL;
+		node->next = NULL;
+	}
+}
+
+/* Gets the absolute path to a node into the provided buffer.
+ *
+ * Populates 'buf' with the path and returns the length of the path on success,
+ * or returns -1 if the path is too long for the provided buffer.
+ */
+static ssize_t get_node_path_locked(struct node* node, char* buf, size_t bufsize) {
+	const char* name;
+	size_t namelen;
+	if (node->graft_path) {
+		name = node->graft_path;
+		namelen = node->graft_pathlen;
+	}
+	else if (node->actual_name) {
+		name = node->actual_name;
+		namelen = node->namelen;
+	}
+	else {
+		name = node->name;
+		namelen = node->namelen;
+	}
+
+	if (bufsize < namelen + 1) {
+		return -1;
+	}
+
+	ssize_t pathlen = 0;
+	if (node->parent && node->graft_path == NULL) {
+		pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 1);
+		if (pathlen < 0) {
+			return -1;
+		}
+		buf[pathlen++] = '/';
+	}
+
+	memcpy(buf + pathlen, name, namelen + 1); /* include trailing \0 */
+	return pathlen + namelen;
+}
+
+/* Finds the absolute path of a file within a given directory.
+ * Performs a case-insensitive search for the file and sets the buffer to the path
+ * of the first matching file.  If 'search' is zero or if no match is found, sets
+ * the buffer to the path that the file would have, assuming the name were case-sensitive.
+ *
+ * Populates 'buf' with the path and returns the actual name (within 'buf') on success,
+ * or returns NULL if the path is too long for the provided buffer.
+ */
+static char* find_file_within(const char* path, const char* name,
+	char* buf, size_t bufsize, int search)
+{
+	size_t pathlen = strlen(path);
+	size_t namelen = strlen(name);
+	size_t childlen = pathlen + namelen + 1;
+	char* actual;
+
+	if (bufsize <= childlen) {
+		return NULL;
+	}
+
+	memcpy(buf, path, pathlen);
+	buf[pathlen] = '/';
+	actual = buf + pathlen + 1;
+	memcpy(actual, name, namelen + 1);
+
+	if (search && access(buf, F_OK)) {
+		struct dirent* entry;
+		DIR* dir = opendir(path);
+		if (!dir) {
+			ERROR("opendir %s failed: %s\n", path, strerror(errno));
+			return actual;
+		}
+		while ((entry = readdir(dir))) {
+			if (!strcasecmp(entry->d_name, name)) {
+				/* we have a match - replace the name, don't need to copy the null again */
+				memcpy(actual, entry->d_name, namelen);
+				break;
+			}
+		}
+		closedir(dir);
+	}
+	return actual;
+}
+
+static void attr_from_stat(struct fuse* fuse, struct fuse_attr *attr,
+	const struct stat *s, const struct node* node) {
+	attr->ino = node->ino;
+	attr->size = s->st_size;
+	attr->blocks = s->st_blocks;
+	attr->atime = s->st_atim.tv_sec;
+	attr->mtime = s->st_mtim.tv_sec;
+	attr->ctime = s->st_ctim.tv_sec;
+	attr->atimensec = s->st_atim.tv_nsec;
+	attr->mtimensec = s->st_mtim.tv_nsec;
+	attr->ctimensec = s->st_ctim.tv_nsec;
+	attr->mode = s->st_mode;
+	attr->nlink = s->st_nlink;
+
+	attr->uid = node->uid;
+
+	if (fuse->gid == AID_SDCARD_RW) {
+		/* As an optimization, certain trusted system components only run
+		 * as owner but operate across all users. Since we're now handing
+		 * out the sdcard_rw GID only to trusted apps, we're okay relaxing
+		 * the user boundary enforcement for the default view. The UIDs
+		 * assigned to app directories are still multiuser aware. */
+		attr->gid = AID_SDCARD_RW;
+	}
+	else {
+		attr->gid = multiuser_get_uid(node->userid, fuse->gid);
+	}
+
+	int visible_mode = 0775 & ~fuse->mask;
+	if (node->perm == PERM_PRE_ROOT) {
+		/* Top of multi-user view should always be visible to ensure
+		 * secondary users can traverse inside. */
+		visible_mode = 0711;
+	}
+	else if (node->under_android) {
+		/* Block "other" access to Android directories, since only apps
+		 * belonging to a specific user should be in there; we still
+		 * leave +x open for the default view. */
+		if (fuse->gid == AID_SDCARD_RW) {
+			visible_mode = visible_mode & ~0006;
+		}
+		else {
+			visible_mode = visible_mode & ~0007;
+		}
+	}
+	int owner_mode = s->st_mode & 0700;
+	int filtered_mode = visible_mode & (owner_mode | (owner_mode >> 3) | (owner_mode >> 6));
+	attr->mode = (attr->mode & S_IFMT) | filtered_mode;
+}
+
+static int touch(char* path, mode_t mode) {
+	int fd = open(path, O_RDWR | O_CREAT | O_EXCL | O_NOFOLLOW, mode);
+	if (fd == -1) {
+		if (errno == EEXIST) {
+			return 0;
+		}
+		else {
+			ERROR("Failed to open(%s): %s\n", path, strerror(errno));
+			return -1;
+		}
+	}
+	close(fd);
+	return 0;
+}
+
+static void derive_permissions_locked(struct fuse* fuse, struct node *parent,
+	struct node *node) {
+	appid_t appid;
+
+	/* By default, each node inherits from its parent */
+	node->perm = PERM_INHERIT;
+	node->userid = parent->userid;
+	node->uid = parent->uid;
+	node->under_android = parent->under_android;
+
+	/* Derive custom permissions based on parent and current node */
+	switch (parent->perm) {
+	case PERM_INHERIT:
+		/* Already inherited above */
+		break;
+	case PERM_PRE_ROOT:
+		/* Legacy internal layout places users at top level */
+		node->perm = PERM_ROOT;
+		node->userid = strtoul(node->name, NULL, 10);
+		break;
+	case PERM_ROOT:
+		/* Assume masked off by default. */
+		if (!strcasecmp(node->name, "Android")) {
+			/* App-specific directories inside; let anyone traverse */
+			node->perm = PERM_ANDROID;
+			node->under_android = true;
+		}
+		break;
+	case PERM_ANDROID:
+		if (!strcasecmp(node->name, "data")) {
+			/* App-specific directories inside; let anyone traverse */
+			node->perm = PERM_ANDROID_DATA;
+		}
+		else if (!strcasecmp(node->name, "obb")) {
+			/* App-specific directories inside; let anyone traverse */
+			node->perm = PERM_ANDROID_OBB;
+			/* Single OBB directory is always shared */
+			node->graft_path = fuse->global->obb_path;
+			node->graft_pathlen = strlen(fuse->global->obb_path);
+		}
+		else if (!strcasecmp(node->name, "media")) {
+			/* App-specific directories inside; let anyone traverse */
+			node->perm = PERM_ANDROID_MEDIA;
+		}
+		break;
+	case PERM_ANDROID_DATA:
+	case PERM_ANDROID_OBB:
+	case PERM_ANDROID_MEDIA:
+		appid = (appid_t)(uintptr_t)hashmapGet(fuse->global->package_to_appid, node->name);
+		if (appid != 0) {
+			node->uid = multiuser_get_uid(parent->userid, appid);
+		}
+		break;
+	}
+}
+
+static void derive_permissions_recursive_locked(struct fuse* fuse, struct node *parent) {
+	struct node *node;
+	for (node = parent->child; node; node = node->next) {
+		derive_permissions_locked(fuse, parent, node);
+		if (node->child) {
+			derive_permissions_recursive_locked(fuse, node);
+		}
+	}
+}
+
+/* Kernel has already enforced everything we returned through
+ * derive_permissions_locked(), so this is used to lock down access
+ * even further, such as enforcing that apps hold sdcard_rw. */
+static bool check_caller_access_to_name(struct fuse* fuse,
+	const struct fuse_in_header *hdr, const struct node* parent_node,
+	const char* name, int mode) {
+	/* Always block security-sensitive files at root */
+	if (parent_node && parent_node->perm == PERM_ROOT) {
+		if (!strcasecmp(name, "autorun.inf")
+			|| !strcasecmp(name, ".android_secure")
+			|| !strcasecmp(name, "android_secure")) {
+			return false;
+		}
+	}
+
+	/* Root always has access; access for any other UIDs should always
+	 * be controlled through packages.list. */
+	if (hdr->uid == 0) {
+		return true;
+	}
+
+	/* No extra permissions to enforce */
+	return true;
+}
+
+static bool check_caller_access_to_node(struct fuse* fuse,
+	const struct fuse_in_header *hdr, const struct node* node, int mode) {
+	return check_caller_access_to_name(fuse, hdr, node->parent, node->name, mode);
+}
+
+struct node *create_node_locked(struct fuse* fuse,
+	struct node *parent, const char *name, const char* actual_name)
+{
+	struct node *node;
+	size_t namelen = strlen(name);
+
+	// Detect overflows in the inode counter. "4 billion nodes should be enough
+	// for everybody".
+	if (fuse->global->inode_ctr == 0) {
+		ERROR("No more inode numbers available");
+		return NULL;
+	}
+
+	node = (struct node *)calloc(1, sizeof(struct node));
+	if (!node) {
+		return NULL;
+	}
+	node->name = (char *)malloc(namelen + 1);
+	if (!node->name) {
+		free(node);
+		return NULL;
+	}
+	memcpy(node->name, name, namelen + 1);
+	if (strcmp(name, actual_name)) {
+		node->actual_name = (char *)malloc(namelen + 1);
+		if (!node->actual_name) {
+			free(node->name);
+			free(node);
+			return NULL;
+		}
+		memcpy(node->actual_name, actual_name, namelen + 1);
+	}
+	node->namelen = namelen;
+	node->nid = ptr_to_id(node);
+	node->ino = fuse->global->inode_ctr++;
+	node->gen = fuse->global->next_generation++;
+
+	node->deleted = false;
+
+	derive_permissions_locked(fuse, parent, node);
+	acquire_node_locked(node);
+	add_node_to_parent_locked(node, parent);
+	return node;
+}
+
+static int rename_node_locked(struct node *node, const char *name,
+	const char* actual_name)
+{
+	size_t namelen = strlen(name);
+	int need_actual_name = strcmp(name, actual_name);
+
+	/* make the storage bigger without actually changing the name
+	 * in case an error occurs part way */
+	if (namelen > node->namelen) {
+		char* new_name = (char *)realloc(node->name, namelen + 1);
+		if (!new_name) {
+			return -ENOMEM;
+		}
+		node->name = new_name;
+		if (need_actual_name && node->actual_name) {
+			char* new_actual_name = (char *)realloc(node->actual_name, namelen + 1);
+			if (!new_actual_name) {
+				return -ENOMEM;
+			}
+			node->actual_name = new_actual_name;
+		}
+	}
+
+	/* update the name, taking care to allocate storage before overwriting the old name */
+	if (need_actual_name) {
+		if (!node->actual_name) {
+			node->actual_name = (char *)malloc(namelen + 1);
+			if (!node->actual_name) {
+				return -ENOMEM;
+			}
+		}
+		memcpy(node->actual_name, actual_name, namelen + 1);
+	}
+	else {
+		free(node->actual_name);
+		node->actual_name = NULL;
+	}
+	memcpy(node->name, name, namelen + 1);
+	node->namelen = namelen;
+	return 0;
+}
+
+static struct node *lookup_node_by_id_locked(struct fuse *fuse, __u64 nid)
+{
+	if (nid == FUSE_ROOT_ID) {
+		return &fuse->global->root;
+	}
+	else {
+		return (struct node *)id_to_ptr(nid);
+	}
+}
+
+static struct node* lookup_node_and_path_by_id_locked(struct fuse* fuse, __u64 nid,
+	char* buf, size_t bufsize)
+{
+	struct node* node = lookup_node_by_id_locked(fuse, nid);
+	if (node && get_node_path_locked(node, buf, bufsize) < 0) {
+		node = NULL;
+	}
+	return node;
+}
+
+static struct node *lookup_child_by_name_locked(struct node *node, const char *name)
+{
+	for (node = node->child; node; node = node->next) {
+		/* use exact string comparison, nodes that differ by case
+		 * must be considered distinct even if they refer to the same
+		 * underlying file as otherwise operations such as "mv x x"
+		 * will not work because the source and target nodes are the same. */
+		if (!strcmp(name, node->name) && !node->deleted) {
+			return node;
+		}
+	}
+	return 0;
+}
+
+static struct node* acquire_or_create_child_locked(
+	struct fuse* fuse, struct node* parent,
+	const char* name, const char* actual_name)
+{
+	struct node* child = lookup_child_by_name_locked(parent, name);
+	if (child) {
+		acquire_node_locked(child);
+	}
+	else {
+		child = create_node_locked(fuse, parent, name, actual_name);
+	}
+	return child;
+}
+
+static void fuse_status(struct fuse *fuse, __u64 unique, int err)
+{
+	struct fuse_out_header hdr;
+	hdr.len = sizeof(hdr);
+	hdr.error = err;
+	hdr.unique = unique;
+	write(fuse->fd, &hdr, sizeof(hdr));
+}
+
+static void fuse_reply(struct fuse *fuse, __u64 unique, void *data, int len)
+{
+	struct fuse_out_header hdr;
+	struct iovec vec[2];
+	int res;
+
+	hdr.len = len + sizeof(hdr);
+	hdr.error = 0;
+	hdr.unique = unique;
+
+	vec[0].iov_base = &hdr;
+	vec[0].iov_len = sizeof(hdr);
+	vec[1].iov_base = data;
+	vec[1].iov_len = len;
+
+	res = writev(fuse->fd, vec, 2);
+	if (res < 0) {
+		ERROR("*** REPLY FAILED *** %d\n", errno);
+	}
+}
+
+static int fuse_reply_entry(struct fuse* fuse, __u64 unique,
+	struct node* parent, const char* name, const char* actual_name,
+	const char* path)
+{
+	struct node* node;
+	struct fuse_entry_out out;
+	struct stat s;
+
+	if (lstat(path, &s) < 0) {
+		return -errno;
+	}
+
+	pthread_mutex_lock(&fuse->global->lock);
+	node = acquire_or_create_child_locked(fuse, parent, name, actual_name);
+	if (!node) {
+		pthread_mutex_unlock(&fuse->global->lock);
+		return -ENOMEM;
+	}
+	memset(&out, 0, sizeof(out));
+	attr_from_stat(fuse, &out.attr, &s, node);
+	out.attr_valid = 10;
+	out.entry_valid = 10;
+	out.nodeid = node->nid;
+	out.generation = node->gen;
+	pthread_mutex_unlock(&fuse->global->lock);
+	fuse_reply(fuse, unique, &out, sizeof(out));
+	return NO_STATUS;
+}
+
+static int fuse_reply_attr(struct fuse* fuse, __u64 unique, const struct node* node,
+	const char* path)
+{
+	struct fuse_attr_out out;
+	struct stat s;
+
+	if (lstat(path, &s) < 0) {
+		return -errno;
+	}
+	memset(&out, 0, sizeof(out));
+	attr_from_stat(fuse, &out.attr, &s, node);
+	out.attr_valid = 10;
+	fuse_reply(fuse, unique, &out, sizeof(out));
+	return NO_STATUS;
+}
+
+static void fuse_notify_delete(struct fuse* fuse, const __u64 parent,
+	const __u64 child, const char* name) {
+	struct fuse_out_header hdr;
+	struct fuse_notify_delete_out data;
+	struct iovec vec[3];
+	size_t namelen = strlen(name);
+	int res;
+
+	hdr.len = sizeof(hdr) + sizeof(data) + namelen + 1;
+	hdr.error = FUSE_NOTIFY_DELETE;
+	hdr.unique = 0;
+
+	data.parent = parent;
+	data.child = child;
+	data.namelen = namelen;
+	data.padding = 0;
+
+	vec[0].iov_base = &hdr;
+	vec[0].iov_len = sizeof(hdr);
+	vec[1].iov_base = &data;
+	vec[1].iov_len = sizeof(data);
+	vec[2].iov_base = (void*)name;
+	vec[2].iov_len = namelen + 1;
+
+	res = writev(fuse->fd, vec, 3);
+	/* Ignore ENOENT, since other views may not have seen the entry */
+	if (res < 0 && errno != ENOENT) {
+		ERROR("*** NOTIFY FAILED *** %d\n", errno);
+	}
+}
+
+static int handle_lookup(struct fuse* fuse, struct fuse_handler* handler,
+	const struct fuse_in_header *hdr, const char* name)
+{
+	struct node* parent_node;
+	char parent_path[PATH_MAX];
+	char child_path[PATH_MAX];
+	const char* actual_name;
+
+	pthread_mutex_lock(&fuse->global->lock);
+	parent_node = lookup_node_and_path_by_id_locked(fuse, hdr->nodeid,
+		parent_path, sizeof(parent_path));
+	TRACE("[%d] LOOKUP %s @ %" PRIx64" (%s)\n", handler->token, name, hdr->nodeid, parent_node ? parent_node->name : "?");
+
+	pthread_mutex_unlock(&fuse->global->lock);
+
+	if (!parent_node || !(actual_name = find_file_within(parent_path, name,
+		child_path, sizeof(child_path), 1))) {
+		return -ENOENT;
+	}
+	if (!check_caller_access_to_name(fuse, hdr, parent_node, name, R_OK)) {
+		return -EACCES;
+	}
+
+	return fuse_reply_entry(fuse, hdr->unique, parent_node, name, actual_name, child_path);
+}
+
+static int handle_forget(struct fuse* fuse, struct fuse_handler* handler,
+	const struct fuse_in_header *hdr, const struct fuse_forget_in *req)
+{
+	struct node* node;
+
+	pthread_mutex_lock(&fuse->global->lock);
+	node = lookup_node_by_id_locked(fuse, hdr->nodeid);
+	TRACE("[%d] FORGET #%" PRIu64" @ %" PRIx64" (%s)\n", handler->token, req->nlookup, hdr->nodeid, node ? node->name : "?");
+
+	if (node) {
+		__u64 n = req->nlookup;
+		while (n--) {
+			release_node_locked(node);
+		}
+	}
+	pthread_mutex_unlock(&fuse->global->lock);
+	return NO_STATUS; /* no reply */
+}
+
+static int handle_getattr(struct fuse* fuse, struct fuse_handler* handler,
+	const struct fuse_in_header *hdr, const struct fuse_getattr_in *req)
+{
+	struct node* node;
+	char path[PATH_MAX];
+
+	pthread_mutex_lock(&fuse->global->lock);
+	node = lookup_node_and_path_by_id_locked(fuse, hdr->nodeid, path, sizeof(path));
+	TRACE("[%d] GETATTR flags=%x fh=%" PRIx64" @ %" PRIx64" (%s)\n", handler->token,
+	      req->getattr_flags, req->fh, hdr->nodeid, node ? node->name : "?");
+
+	pthread_mutex_unlock(&fuse->global->lock);
+
+	if (!node) {
+		return -ENOENT;
+	}
+	if (!check_caller_access_to_node(fuse, hdr, node, R_OK)) {
+		return -EACCES;
+	}
+
+	return fuse_reply_attr(fuse, hdr->unique, node, path);
+}
+
+static int handle_setattr(struct fuse* fuse, struct fuse_handler* handler,
+	const struct fuse_in_header *hdr, const struct fuse_setattr_in *req)
+{
+	struct node* node;
+	char path[PATH_MAX];
+	struct timespec times[2];
+
+	pthread_mutex_lock(&fuse->global->lock);
+	node = lookup_node_and_path_by_id_locked(fuse, hdr->nodeid, path, sizeof(path));
+	TRACE("[%d] SETATTR fh=%" PRIx64" valid=%x @ %" PRIx64" (%s)\n", handler->token,
+	     req->fh, req->valid, hdr->nodeid, node ? node->name : "?");
+
+	pthread_mutex_unlock(&fuse->global->lock);
+
+	if (!node) {
+		return -ENOENT;
+	}
+
+	if (!(req->valid & FATTR_FH) &&
+		!check_caller_access_to_node(fuse, hdr, node, W_OK)) {
+		return -EACCES;
+	}
+
+	/* XXX: incomplete implementation on purpose.
+	 * chmod/chown should NEVER be implemented.*/
+
+	if ((req->valid & FATTR_SIZE) && truncate64(path, req->size) < 0) {
+		return -errno;
+	}
+
+	/* Handle changing atime and mtime.  If FATTR_ATIME_and FATTR_ATIME_NOW
+	 * are both set, then set it to the current time.  Else, set it to the
+	 * time specified in the request.  Same goes for mtime.  Use utimensat(2)
+	 * as it allows ATIME and MTIME to be changed independently, and has
+	 * nanosecond resolution which fuse also has.
+	 */
+	if (req->valid & (FATTR_ATIME | FATTR_MTIME)) {
+		times[0].tv_nsec = UTIME_OMIT;
+		times[1].tv_nsec = UTIME_OMIT;
+		if (req->valid & FATTR_ATIME) {
+			if (req->valid & FATTR_ATIME_NOW) {
+				times[0].tv_nsec = UTIME_NOW;
+			}
+			else {
+				times[0].tv_sec = req->atime;
+				times[0].tv_nsec = req->atimensec;
+			}
+		}
+		if (req->valid & FATTR_MTIME) {
+			if (req->valid & FATTR_MTIME_NOW) {
+				times[1].tv_nsec = UTIME_NOW;
+			}
+			else {
+				times[1].tv_sec = req->mtime;
+				times[1].tv_nsec = req->mtimensec;
+			}
+		}
+		TRACE("[%d] Calling utimensat on %s with atime %ld, mtime=%ld\n",
+		    handler->token, path, times[0].tv_sec, times[1].tv_sec);
+
+		if (utimensat(-1, path, times, 0) < 0) {
+			return -errno;
+		}
+	}
+	return fuse_reply_attr(fuse, hdr->unique, node, path);
+}
+
+static int handle_mknod(struct fuse* fuse, struct fuse_handler* handler,
+	const struct fuse_in_header* hdr, const struct fuse_mknod_in* req, const char* name)
+{
+	struct node* parent_node;
+	char parent_path[PATH_MAX];
+	char child_path[PATH_MAX];
+	const char* actual_name;
+
+	pthread_mutex_lock(&fuse->global->lock);
+	parent_node = lookup_node_and_path_by_id_locked(fuse, hdr->nodeid,
+		parent_path, sizeof(parent_path));
+	TRACE("[%d] MKNOD %s 0%o @ %" PRIx64" (%s)\n", handler->token,
+	    name, req->mode, hdr->nodeid, parent_node ? parent_node->name : "?");
+
+	pthread_mutex_unlock(&fuse->global->lock);
+
+	if (!parent_node || !(actual_name = find_file_within(parent_path, name,
+		child_path, sizeof(child_path), 1))) {
+		return -ENOENT;
+	}
+	if (!check_caller_access_to_name(fuse, hdr, parent_node, name, W_OK)) {
+		return -EACCES;
+	}
+	__u32 mode = (req->mode & (~0777)) | 0664;
+	if (mknod(child_path, mode, req->rdev) < 0) {
+		return -errno;
+	}
+	return fuse_reply_entry(fuse, hdr->unique, parent_node, name, actual_name, child_path);
+}
+
+static int handle_mkdir(struct fuse* fuse, struct fuse_handler* handler,
+	const struct fuse_in_header* hdr, const struct fuse_mkdir_in* req, const char* name)
+{
+	struct node* parent_node;
+	char parent_path[PATH_MAX];
+	char child_path[PATH_MAX];
+	const char* actual_name;
+
+	pthread_mutex_lock(&fuse->global->lock);
+	parent_node = lookup_node_and_path_by_id_locked(fuse, hdr->nodeid,
+		parent_path, sizeof(parent_path));
+	TRACE("[%d] MKDIR %s 0%o @ %" PRIx64" (%s)\n", handler->token,
+	    name, req->mode, hdr->nodeid, parent_node ? parent_node->name : "?");
+
+	pthread_mutex_unlock(&fuse->global->lock);
+
+	if (!parent_node || !(actual_name = find_file_within(parent_path, name,
+		child_path, sizeof(child_path), 1))) {
+		return -ENOENT;
+	}
+	if (!check_caller_access_to_name(fuse, hdr, parent_node, name, W_OK)) {
+		return -EACCES;
+	}
+	__u32 mode = (req->mode & (~0777)) | 0775;
+	if (mkdir(child_path, mode) < 0) {
+		return -errno;
+	}
+
+	/* When creating /Android/data and /Android/obb, mark them as .nomedia */
+	if (parent_node->perm == PERM_ANDROID && !strcasecmp(name, "data")) {
+		char nomedia[PATH_MAX];
+		snprintf(nomedia, PATH_MAX, "%s/.nomedia", child_path);
+		if (touch(nomedia, 0664) != 0) {
+			ERROR("Failed to touch(%s): %s\n", nomedia, strerror(errno));
+			return -ENOENT;
+		}
+	}
+	if (parent_node->perm == PERM_ANDROID && !strcasecmp(name, "obb")) {
+		char nomedia[PATH_MAX];
+		snprintf(nomedia, PATH_MAX, "%s/.nomedia", fuse->global->obb_path);
+		if (touch(nomedia, 0664) != 0) {
+			ERROR("Failed to touch(%s): %s\n", nomedia, strerror(errno));
+			return -ENOENT;
+		}
+	}
+
+	return fuse_reply_entry(fuse, hdr->unique, parent_node, name, actual_name, child_path);
+}
+
+static int handle_unlink(struct fuse* fuse, struct fuse_handler* handler,
+	const struct fuse_in_header* hdr, const char* name)
+{
+	struct node* parent_node;
+	struct node* child_node;
+	char parent_path[PATH_MAX];
+	char child_path[PATH_MAX];
+
+	pthread_mutex_lock(&fuse->global->lock);
+	parent_node = lookup_node_and_path_by_id_locked(fuse, hdr->nodeid,
+		parent_path, sizeof(parent_path));
+	TRACE("[%d] UNLINK %s @ %" PRIx64" (%s)\n", handler->token,
+		name, hdr->nodeid, parent_node ? parent_node->name : "?");
+
+	pthread_mutex_unlock(&fuse->global->lock);
+
+	if (!parent_node || !find_file_within(parent_path, name,
+		child_path, sizeof(child_path), 1)) {
+		return -ENOENT;
+	}
+	if (!check_caller_access_to_name(fuse, hdr, parent_node, name, W_OK)) {
+		return -EACCES;
+	}
+	if (unlink(child_path) < 0) {
+		return -errno;
+	}
+	pthread_mutex_lock(&fuse->global->lock);
+	child_node = lookup_child_by_name_locked(parent_node, name);
+	if (child_node) {
+		child_node->deleted = true;
+	}
+	pthread_mutex_unlock(&fuse->global->lock);
+	if (parent_node && child_node) {
+		/* Tell all other views that node is gone */
+		TRACE("[%d] fuse_notify_delete parent=%" PRIx64", child=%" PRIx64", name=%s\n",
+			handler->token, (uint64_t)parent_node->nid, (uint64_t)child_node->nid, name);
+
+		if (fuse != fuse->global->fuse_default) {
+			fuse_notify_delete(fuse->global->fuse_default, parent_node->nid, child_node->nid, name);
+		}
+		if (fuse != fuse->global->fuse_read) {
+			fuse_notify_delete(fuse->global->fuse_read, parent_node->nid, child_node->nid, name);
+		}
+		if (fuse != fuse->global->fuse_write) {
+			fuse_notify_delete(fuse->global->fuse_write, parent_node->nid, child_node->nid, name);
+		}
+		if (fuse != fuse->global->fuse_full) {
+			fuse_notify_delete(fuse->global->fuse_full, parent_node->nid, child_node->nid, name);
+		}
+	}
+	return 0;
+}
+
+static int handle_rmdir(struct fuse* fuse, struct fuse_handler* handler,
+	const struct fuse_in_header* hdr, const char* name)
+{
+	struct node* child_node;
+	struct node* parent_node;
+	char parent_path[PATH_MAX];
+	char child_path[PATH_MAX];
+
+	pthread_mutex_lock(&fuse->global->lock);
+	parent_node = lookup_node_and_path_by_id_locked(fuse, hdr->nodeid,
+		parent_path, sizeof(parent_path));
+	TRACE("[%d] RMDIR %s @ %" PRIx64" (%s)\n", handler->token,
+		name, hdr->nodeid, parent_node ? parent_node->name : "?");
+
+	pthread_mutex_unlock(&fuse->global->lock);
+
+	if (!parent_node || !find_file_within(parent_path, name,
+		child_path, sizeof(child_path), 1)) {
+		return -ENOENT;
+	}
+	if (!check_caller_access_to_name(fuse, hdr, parent_node, name, W_OK)) {
+		return -EACCES;
+	}
+	if (rmdir(child_path) < 0) {
+		return -errno;
+	}
+	pthread_mutex_lock(&fuse->global->lock);
+	child_node = lookup_child_by_name_locked(parent_node, name);
+	if (child_node) {
+		child_node->deleted = true;
+	}
+	pthread_mutex_unlock(&fuse->global->lock);
+	if (parent_node && child_node) {
+		/* Tell all other views that node is gone */
+		TRACE("[%d] fuse_notify_delete parent=%" PRIx64", child=%" PRIx64", name=%s\n",
+			handler->token, (uint64_t)parent_node->nid, (uint64_t)child_node->nid, name);
+
+		if (fuse != fuse->global->fuse_default) {
+			fuse_notify_delete(fuse->global->fuse_default, parent_node->nid, child_node->nid, name);
+		}
+		if (fuse != fuse->global->fuse_read) {
+			fuse_notify_delete(fuse->global->fuse_read, parent_node->nid, child_node->nid, name);
+		}
+		if (fuse != fuse->global->fuse_write) {
+			fuse_notify_delete(fuse->global->fuse_write, parent_node->nid, child_node->nid, name);
+		}
+		if (fuse != fuse->global->fuse_full) {
+			fuse_notify_delete(fuse->global->fuse_full, parent_node->nid, child_node->nid, name);
+		}
+	}
+	return 0;
+}
+
+static int handle_rename(struct fuse* fuse, struct fuse_handler* handler,
+	const struct fuse_in_header* hdr, const struct fuse_rename_in* req,
+	const char* old_name, const char* new_name)
+{
+	struct node* old_parent_node;
+	struct node* new_parent_node;
+	struct node* child_node;
+	char old_parent_path[PATH_MAX];
+	char new_parent_path[PATH_MAX];
+	char old_child_path[PATH_MAX];
+	char new_child_path[PATH_MAX];
+	const char* new_actual_name;
+	int res;
+	int search;
+
+	pthread_mutex_lock(&fuse->global->lock);
+	old_parent_node = lookup_node_and_path_by_id_locked(fuse, hdr->nodeid,
+		old_parent_path, sizeof(old_parent_path));
+	new_parent_node = lookup_node_and_path_by_id_locked(fuse, req->newdir,
+		new_parent_path, sizeof(new_parent_path));
+	TRACE("[%d] RENAME %s->%s @ %" PRIx64" (%s) -> %" PRIx64" (%s)\n", handler->token,
+		old_name, new_name,
+		hdr->nodeid, old_parent_node ? old_parent_node->name : "?",
+		req->newdir, new_parent_node ? new_parent_node->name : "?");
+
+	if (!old_parent_node || !new_parent_node) {
+		res = -ENOENT;
+		goto lookup_error;
+	}
+	if (!check_caller_access_to_name(fuse, hdr, old_parent_node, old_name, W_OK)) {
+		res = -EACCES;
+		goto lookup_error;
+	}
+	if (!check_caller_access_to_name(fuse, hdr, new_parent_node, new_name, W_OK)) {
+		res = -EACCES;
+		goto lookup_error;
+	}
+	child_node = lookup_child_by_name_locked(old_parent_node, old_name);
+	if (!child_node || get_node_path_locked(child_node,
+		old_child_path, sizeof(old_child_path)) < 0) {
+		res = -ENOENT;
+		goto lookup_error;
+	}
+	acquire_node_locked(child_node);
+	pthread_mutex_unlock(&fuse->global->lock);
+
+	/* Special case for renaming a file where destination is same path
+	 * differing only by case.  In this case we don't want to look for a case
+	 * insensitive match.  This allows commands like "mv foo FOO" to work as expected.
+	 */
+	search = old_parent_node != new_parent_node
+		|| strcasecmp(old_name, new_name);
+	if (!(new_actual_name = find_file_within(new_parent_path, new_name,
+		new_child_path, sizeof(new_child_path), search))) {
+		res = -ENOENT;
+		goto io_error;
+	}
+
+	TRACE("[%d] RENAME %s->%s\n", handler->token, old_child_path, new_child_path);
+
+	res = rename(old_child_path, new_child_path);
+	if (res < 0) {
+		res = -errno;
+		goto io_error;
+	}
+
+	pthread_mutex_lock(&fuse->global->lock);
+	res = rename_node_locked(child_node, new_name, new_actual_name);
+	if (!res) {
+		remove_node_from_parent_locked(child_node);
+		derive_permissions_locked(fuse, new_parent_node, child_node);
+		derive_permissions_recursive_locked(fuse, child_node);
+		add_node_to_parent_locked(child_node, new_parent_node);
+	}
+	goto done;
+
+io_error:
+	pthread_mutex_lock(&fuse->global->lock);
+done:
+	release_node_locked(child_node);
+lookup_error:
+	pthread_mutex_unlock(&fuse->global->lock);
+	return res;
+
+}
+
+static int open_flags_to_access_mode(int open_flags) {
+	if ((open_flags & O_ACCMODE) == O_RDONLY) {
+		return R_OK;
+	}
+	else if ((open_flags & O_ACCMODE) == O_WRONLY) {
+		return W_OK;
+	}
+	else {
+		/* Probably O_RDRW, but treat as default to be safe */
+		return R_OK | W_OK;
+	}
+}
+
+static int handle_open(struct fuse* fuse, struct fuse_handler* handler,
+	const struct fuse_in_header* hdr, const struct fuse_open_in* req)
+{
+	struct node* node;
+	char path[PATH_MAX];
+	struct fuse_open_out out;
+	struct handle *h;
+
+	pthread_mutex_lock(&fuse->global->lock);
+	node = lookup_node_and_path_by_id_locked(fuse, hdr->nodeid, path, sizeof(path));
+	TRACE("[%d] OPEN 0%o @ %" PRIx64" (%s)\n", handler->token,
+		req->flags, hdr->nodeid, node ? node->name : "?");
+
+	pthread_mutex_unlock(&fuse->global->lock);
+
+	if (!node) {
+		return -ENOENT;
+	}
+	if (!check_caller_access_to_node(fuse, hdr, node,
+		open_flags_to_access_mode(req->flags))) {
+		return -EACCES;
+	}
+	h = (struct handle *)malloc(sizeof(*h));
+	if (!h) {
+		return -ENOMEM;
+	}
+	TRACE("[%d] OPEN %s\n", handler->token, path);
+	h->fd = open(path, req->flags);
+	if (h->fd < 0) {
+		free(h);
+		return -errno;
+	}
+	out.fh = ptr_to_id(h);
+	out.open_flags = 0;
+	out.padding = 0;
+	fuse_reply(fuse, hdr->unique, &out, sizeof(out));
+	return NO_STATUS;
+}
+
+static int handle_read(struct fuse* fuse, struct fuse_handler* handler,
+	const struct fuse_in_header* hdr, const struct fuse_read_in* req)
+{
+	struct handle *h = (struct handle *)id_to_ptr(req->fh);
+	__u64 unique = hdr->unique;
+	__u32 size = req->size;
+	__u64 offset = req->offset;
+	int res;
+	__u8 *read_buffer = (__u8 *)((uintptr_t)(handler->read_buffer + PAGE_SIZE) & ~((uintptr_t)PAGE_SIZE - 1));
+
+	/* Don't access any other fields of hdr or req beyond this point, the read buffer
+	 * overlaps the request buffer and will clobber data in the request.  This
+	 * saves us 128KB per request handler thread at the cost of this scary comment. */
+
+	TRACE("[%d] READ %p(%d) %u@%" PRIu64"\n", handler->token,
+		h, h->fd, size, (uint64_t)offset);
+
+	if (size > MAX_READ) {
+		return -EINVAL;
+	}
+	res = pread64(h->fd, read_buffer, size, offset);
+	if (res < 0) {
+		return -errno;
+	}
+	fuse_reply(fuse, unique, read_buffer, res);
+	return NO_STATUS;
+}
+
+static int handle_write(struct fuse* fuse, struct fuse_handler* handler,
+	const struct fuse_in_header* hdr, const struct fuse_write_in* req,
+	const void* buffer)
+{
+	struct fuse_write_out out;
+	struct handle *h = (struct handle *)id_to_ptr(req->fh);
+	int res;
+	__u8 aligned_buffer[req->size] __attribute__((__aligned__(PAGE_SIZE)));
+
+	if (req->flags & O_DIRECT) {
+		memcpy(aligned_buffer, buffer, req->size);
+		buffer = (const __u8*)aligned_buffer;
+	}
+
+	TRACE("[%d] WRITE %p(%d) %u@%" PRIu64"\n", handler->token,
+		h, h->fd, req->size, req->offset);
+
+	res = pwrite64(h->fd, buffer, req->size, req->offset);
+	if (res < 0) {
+		return -errno;
+	}
+	out.size = res;
+	out.padding = 0;
+	fuse_reply(fuse, hdr->unique, &out, sizeof(out));
+	return NO_STATUS;
+}
+
+static int handle_statfs(struct fuse* fuse, struct fuse_handler* handler,
+	const struct fuse_in_header* hdr)
+{
+	char path[PATH_MAX];
+	struct statfs stat;
+	struct fuse_statfs_out out;
+	int res;
+
+	pthread_mutex_lock(&fuse->global->lock);
+	TRACE("[%d] STATFS\n", handler->token);
+
+	res = get_node_path_locked(&fuse->global->root, path, sizeof(path));
+	pthread_mutex_unlock(&fuse->global->lock);
+	if (res < 0) {
+		return -ENOENT;
+	}
+	if (statfs(fuse->global->root.name, &stat) < 0) {
+		return -errno;
+	}
+	memset(&out, 0, sizeof(out));
+	out.st.blocks = stat.f_blocks;
+	out.st.bfree = stat.f_bfree;
+	out.st.bavail = stat.f_bavail;
+	out.st.files = stat.f_files;
+	out.st.ffree = stat.f_ffree;
+	out.st.bsize = stat.f_bsize;
+	out.st.namelen = stat.f_namelen;
+	out.st.frsize = stat.f_frsize;
+	fuse_reply(fuse, hdr->unique, &out, sizeof(out));
+	return NO_STATUS;
+}
+
+static int handle_release(struct fuse* fuse, struct fuse_handler* handler,
+	const struct fuse_in_header* hdr, const struct fuse_release_in* req)
+{
+	struct handle *h = (struct handle *)id_to_ptr(req->fh);
+
+	TRACE("[%d] RELEASE %p(%d)\n", handler->token, h, h->fd);
+
+	close(h->fd);
+	free(h);
+	return 0;
+}
+
+static int handle_fsync(struct fuse* fuse, struct fuse_handler* handler,
+	const struct fuse_in_header* hdr, const struct fuse_fsync_in* req)
+{
+	bool is_dir = (hdr->opcode == FUSE_FSYNCDIR);
+	bool is_data_sync = req->fsync_flags & 1;
+
+	int fd = -1;
+	if (is_dir) {
+		struct dirhandle *dh = (struct dirhandle *)id_to_ptr(req->fh);
+		fd = dirfd(dh->d);
+	}
+	else {
+		struct handle *h = (struct handle *)id_to_ptr(req->fh);
+		fd = h->fd;
+	}
+
+	TRACE("[%d] %s %p(%d) is_data_sync=%d\n", handler->token,
+		is_dir ? "FSYNCDIR" : "FSYNC",
+		id_to_ptr(req->fh), fd, is_data_sync);
+
+	int res = is_data_sync ? fdatasync(fd) : fsync(fd);
+	if (res == -1) {
+		return -errno;
+	}
+	return 0;
+}
+
+static int handle_flush(struct fuse* fuse, struct fuse_handler* handler,
+	const struct fuse_in_header* hdr)
+{
+	TRACE("[%d] FLUSH\n", handler->token);
+	return 0;
+}
+
+static int handle_opendir(struct fuse* fuse, struct fuse_handler* handler,
+	const struct fuse_in_header* hdr, const struct fuse_open_in* req)
+{
+	struct node* node;
+	char path[PATH_MAX];
+	struct fuse_open_out out;
+	struct dirhandle *h;
+
+	pthread_mutex_lock(&fuse->global->lock);
+	node = lookup_node_and_path_by_id_locked(fuse, hdr->nodeid, path, sizeof(path));
+	TRACE("[%d] OPENDIR @ %" PRIx64" (%s)\n", handler->token,
+		hdr->nodeid, node ? node->name : "?");
+
+	pthread_mutex_unlock(&fuse->global->lock);
+
+	if (!node) {
+		return -ENOENT;
+	}
+	if (!check_caller_access_to_node(fuse, hdr, node, R_OK)) {
+		return -EACCES;
+	}
+	h = (struct dirhandle *)malloc(sizeof(*h));
+	if (!h) {
+		return -ENOMEM;
+	}
+	TRACE("[%d] OPENDIR %s\n", handler->token, path);
+
+	h->d = opendir(path);
+	if (!h->d) {
+		free(h);
+		return -errno;
+	}
+	out.fh = ptr_to_id(h);
+	out.open_flags = 0;
+	out.padding = 0;
+	fuse_reply(fuse, hdr->unique, &out, sizeof(out));
+	return NO_STATUS;
+}
+
+static int handle_readdir(struct fuse* fuse, struct fuse_handler* handler,
+	const struct fuse_in_header* hdr, const struct fuse_read_in* req)
+{
+	char buffer[8192];
+	struct fuse_dirent *fde = (struct fuse_dirent*) buffer;
+	struct dirent *de;
+	struct dirhandle *h = (struct dirhandle *)id_to_ptr(req->fh);
+
+	TRACE("[%d] READDIR %p\n", handler->token, h);
+	if (req->offset == 0) {
+		/* rewinddir() might have been called above us, so rewind here too */
+		TRACE("[%d] calling rewinddir()\n", handler->token);
+		rewinddir(h->d);
+	}
+	de = readdir(h->d);
+	if (!de) {
+		return 0;
+	}
+	fde->ino = FUSE_UNKNOWN_INO;
+	/* increment the offset so we can detect when rewinddir() seeks back to the beginning */
+	fde->off = req->offset + 1;
+	fde->type = de->d_type;
+	fde->namelen = strlen(de->d_name);
+	memcpy(fde->name, de->d_name, fde->namelen + 1);
+	fuse_reply(fuse, hdr->unique, fde,
+		FUSE_DIRENT_ALIGN(sizeof(struct fuse_dirent) + fde->namelen));
+	return NO_STATUS;
+}
+
+static int handle_releasedir(struct fuse* fuse, struct fuse_handler* handler,
+	const struct fuse_in_header* hdr, const struct fuse_release_in* req)
+{
+	struct dirhandle *h = (struct dirhandle *)id_to_ptr(req->fh);
+	TRACE("[%d] RELEASEDIR %p\n", handler->token, h);
+	closedir(h->d);
+	free(h);
+	return 0;
+}
+
+static int handle_init(struct fuse* fuse, struct fuse_handler* handler,
+	const struct fuse_in_header* hdr, const struct fuse_init_in* req)
+{
+	struct fuse_init_out out;
+	size_t fuse_struct_size;
+
+	TRACE("[%d] INIT ver=%d.%d maxread=%d flags=%x\n",
+		 handler->token, req->major, req->minor, req->max_readahead, req->flags);
+	/* Kernel 2.6.16 is the first stable kernel with struct fuse_init_out
+	 * defined (fuse version 7.6). The structure is the same from 7.6 through
+	 * 7.22. Beginning with 7.23, the structure increased in size and added
+	 * new parameters.
+	 */
+	if (req->major != FUSE_KERNEL_VERSION || req->minor < 6) {
+        ERROR("Fuse kernel version mismatch: Kernel version %d.%d, Expected at least %d.6",
+             req->major, req->minor, FUSE_KERNEL_VERSION);
+		return -1;
+	}
+
+	/* We limit ourselves to 15 because we don't handle BATCH_FORGET yet */
+	out.minor = MIN(req->minor, 15);
+	fuse_struct_size = sizeof(out);
+#if defined(FUSE_COMPAT_22_INIT_OUT_SIZE)
+	/* FUSE_KERNEL_VERSION >= 23. */
+
+	/* If the kernel only works on minor revs older than or equal to 22,
+	 * then use the older structure size since this code only uses the 7.22
+	 * version of the structure. */
+	if (req->minor <= 22) {
+		fuse_struct_size = FUSE_COMPAT_22_INIT_OUT_SIZE;
+	}
+#endif
+
+	out.major = FUSE_KERNEL_VERSION;
+	out.max_readahead = req->max_readahead;
+	out.flags = FUSE_ATOMIC_O_TRUNC | FUSE_BIG_WRITES;
+	out.max_background = 32;
+	out.congestion_threshold = 32;
+	out.max_write = MAX_WRITE;
+	fuse_reply(fuse, hdr->unique, &out, fuse_struct_size);
+	return NO_STATUS;
+}
+
+static int handle_canonical_path(struct fuse* fuse, struct fuse_handler* handler,
+	const struct fuse_in_header *hdr)
+{
+	struct node* node;
+	char path[PATH_MAX];
+	int len;
+
+	pthread_mutex_lock(&fuse->global->lock);
+	node = lookup_node_and_path_by_id_locked(fuse, hdr->nodeid,
+		path, sizeof(path));
+	TRACE("[%d] CANONICAL_PATH @ %" PRIx64" (%s)\n", handler->token, hdr->nodeid,
+		node ? node->name : "?");
+	pthread_mutex_unlock(&fuse->global->lock);
+
+	if (!node) {
+		return -ENOENT;
+	}
+	if (!check_caller_access_to_node(fuse, hdr, node, R_OK)) {
+		return -EACCES;
+	}
+	len = strlen(path);
+	if (len + 1 > PATH_MAX)
+		len = PATH_MAX - 1;
+	path[PATH_MAX - 1] = 0;
+	fuse_reply(fuse, hdr->unique, path, len + 1);
+	return NO_STATUS;
+}
+
+
+static int handle_fuse_request(struct fuse *fuse, struct fuse_handler* handler,
+	const struct fuse_in_header *hdr, const void *data, size_t data_len)
+{
+	switch (hdr->opcode) {
+	case FUSE_LOOKUP: { /* bytez[] -> entry_out */
+		const char* name = (const char *)data;
+		return handle_lookup(fuse, handler, hdr, name);
+	}
+
+	case FUSE_FORGET: {
+		const struct fuse_forget_in *req = (const struct fuse_forget_in *)data;
+		return handle_forget(fuse, handler, hdr, req);
+	}
+
+	case FUSE_GETATTR: { /* getattr_in -> attr_out */
+		const struct fuse_getattr_in *req = (const struct fuse_getattr_in *)data;
+		return handle_getattr(fuse, handler, hdr, req);
+	}
+
+	case FUSE_SETATTR: { /* setattr_in -> attr_out */
+		const struct fuse_setattr_in *req = (const struct fuse_setattr_in *)data;
+		return handle_setattr(fuse, handler, hdr, req);
+	}
+
+	//    case FUSE_READLINK:
+	//    case FUSE_SYMLINK:
+	case FUSE_MKNOD: { /* mknod_in, bytez[] -> entry_out */
+		const struct fuse_mknod_in *req = (const struct fuse_mknod_in *)data;
+		const char *name = ((const char*)data) + sizeof(*req);
+		return handle_mknod(fuse, handler, hdr, req, name);
+	}
+
+	case FUSE_MKDIR: { /* mkdir_in, bytez[] -> entry_out */
+		const struct fuse_mkdir_in *req = (const struct fuse_mkdir_in *)data;
+		const char *name = ((const char*)data) + sizeof(*req);
+		return handle_mkdir(fuse, handler, hdr, req, name);
+	}
+
+	case FUSE_UNLINK: { /* bytez[] -> */
+		const char* name = (const char *)data;
+		return handle_unlink(fuse, handler, hdr, name);
+	}
+
+	case FUSE_RMDIR: { /* bytez[] -> */
+		const char* name = (const char *)data;
+		return handle_rmdir(fuse, handler, hdr, name);
+	}
+
+	case FUSE_RENAME: { /* rename_in, oldname, newname ->  */
+		const struct fuse_rename_in *req = (const struct fuse_rename_in *)data;
+		const char *old_name = ((const char*)data) + sizeof(*req);
+		const char *new_name = old_name + strlen(old_name) + 1;
+		return handle_rename(fuse, handler, hdr, req, old_name, new_name);
+	}
+
+	//    case FUSE_LINK:
+	case FUSE_OPEN: { /* open_in -> open_out */
+		const struct fuse_open_in *req = (const struct fuse_open_in *)data;
+		return handle_open(fuse, handler, hdr, req);
+	}
+
+	case FUSE_READ: { /* read_in -> byte[] */
+		const struct fuse_read_in *req = (const struct fuse_read_in *)data;
+		return handle_read(fuse, handler, hdr, req);
+	}
+
+	case FUSE_WRITE: { /* write_in, byte[write_in.size] -> write_out */
+		const struct fuse_write_in *req = (const struct fuse_write_in *)data;
+		const void* buffer = (const __u8*)data + sizeof(*req);
+		return handle_write(fuse, handler, hdr, req, buffer);
+	}
+
+	case FUSE_STATFS: { /* getattr_in -> attr_out */
+		return handle_statfs(fuse, handler, hdr);
+	}
+
+	case FUSE_RELEASE: { /* release_in -> */
+		const struct fuse_release_in *req = (const struct fuse_release_in *)data;
+		return handle_release(fuse, handler, hdr, req);
+	}
+
+	case FUSE_FSYNC:
+	case FUSE_FSYNCDIR: {
+		const struct fuse_fsync_in *req = (const struct fuse_fsync_in *)data;
+		return handle_fsync(fuse, handler, hdr, req);
+	}
+
+	//    case FUSE_SETXATTR:
+	//    case FUSE_GETXATTR:
+	//    case FUSE_LISTXATTR:
+	//    case FUSE_REMOVEXATTR:
+	case FUSE_FLUSH: {
+		return handle_flush(fuse, handler, hdr);
+	}
+
+	case FUSE_OPENDIR: { /* open_in -> open_out */
+		const struct fuse_open_in *req = (const struct fuse_open_in *)data;
+		return handle_opendir(fuse, handler, hdr, req);
+	}
+
+	case FUSE_READDIR: {
+		const struct fuse_read_in *req = (const struct fuse_read_in *)data;
+		return handle_readdir(fuse, handler, hdr, req);
+	}
+
+	case FUSE_RELEASEDIR: { /* release_in -> */
+		const struct fuse_release_in *req = (const struct fuse_release_in *)data;
+		return handle_releasedir(fuse, handler, hdr, req);
+	}
+
+	case FUSE_INIT: { /* init_in -> init_out */
+		const struct fuse_init_in *req = (const struct fuse_init_in *)data;
+		return handle_init(fuse, handler, hdr, req);
+	}
+
+	case FUSE_CANONICAL_PATH: { /* nodeid -> bytez[] */
+		return handle_canonical_path(fuse, handler, hdr);
+	}
+
+	default: {
+		TRACE("[%d] NOTIMPL op=%d uniq=%" PRIx64" nid=%" PRIx64"\n",
+			handler->token, hdr->opcode, hdr->unique, hdr->nodeid);
+		return -ENOSYS;
+	}
+	}
+}
+
+static void handle_fuse_requests(struct fuse_handler* handler)
+{
+	ALOGE("main start handle_fuse_requests");
+	struct fuse* fuse = handler->fuse;
+	for (;;) {
+		ssize_t len = TEMP_FAILURE_RETRY(read(fuse->fd,
+			handler->request_buffer, sizeof(handler->request_buffer)));
+		if (len < 0) {
+			if (errno == ENODEV) {
+				ERROR("[%d] someone stole our marbles!\n", handler->token);
+				exit(2);
+			}
+			ERROR("[%d] handle_fuse_requests: errno=%d\n", handler->token, errno);
+			continue;
+		}
+
+		if ((size_t)len < sizeof(struct fuse_in_header)) {
+			ERROR("[%d] request too short: len=%zu\n", handler->token, (size_t)len);
+			continue;
+		}
+
+		const struct fuse_in_header *hdr = (const struct fuse_in_header *)handler->request_buffer;
+		if (hdr->len != (size_t)len) {
+			ERROR("[%d] malformed header: len=%zu, hdr->len=%u\n",
+				 handler->token, (size_t)len, hdr->len);
+			continue;
+		}
+
+		const void *data = handler->request_buffer + sizeof(struct fuse_in_header);
+		size_t data_len = len - sizeof(struct fuse_in_header);
+		__u64 unique = hdr->unique;
+		int res = handle_fuse_request(fuse, handler, hdr, data, data_len);
+
+		/* We do not access the request again after this point because the underlying
+		 * buffer storage may have been reused while processing the request. */
+
+		if (res != NO_STATUS) {
+			if (res) {
+				TRACE("[%d] ERROR %d\n", handler->token, res);
+			}
+			fuse_status(fuse, unique, res);
+		}
+	}
+}
+
+static void* start_handler(void* data)
+{
+	struct fuse_handler* handler = (struct fuse_handler *)data;
+	handle_fuse_requests(handler);
+	return NULL;
+}
+
+static bool remove_str_to_int(void *key, void *value, void *context) {
+	Hashmap* map = (Hashmap *)context;
+	hashmapRemove(map, key);
+	free(key);
+	return true;
+}
+
+static bool package_parse_callback(pkg_info *info, void *userdata) {
+	struct fuse_global *global = (struct fuse_global *)userdata;
+
+	char* name = strdup(info->name);
+	hashmapPut(global->package_to_appid, name, (void*)(uintptr_t)info->uid);
+	packagelist_free(info);
+	return true;
+}
+
+static bool read_package_list(struct fuse_global* global) {
+	pthread_mutex_lock(&global->lock);
+
+	hashmapForEach(global->package_to_appid, remove_str_to_int, global->package_to_appid);
+
+	bool rc = packagelist_parse(package_parse_callback, global);
+//	TRACE("read_package_list: found %zu packages\n",
+//		hashmapSize(global->package_to_appid));
+
+	/* Regenerate ownership details using newly loaded mapping */
+	derive_permissions_recursive_locked(global->fuse_default, &global->root);
+
+	pthread_mutex_unlock(&global->lock);
+
+	return rc;
+}
+
+static void watch_package_list(struct fuse_global* global) {
+	struct inotify_event *event;
+	char event_buf[512];
+
+	int nfd = inotify_init();
+	if (nfd < 0) {
+		ERROR("inotify_init failed: %s\n", strerror(errno));
+		return;
+	}
+	bool active = false;
+	while (1) {
+		if (!active) {
+			int res = inotify_add_watch(nfd, PACKAGES_LIST_FILE, IN_DELETE_SELF);
+			if (res == -1) {
+				if (errno == ENOENT || errno == EACCES) {
+					/* Framework may not have created yet, sleep and retry */
+					ERROR("missing \"%s\"; retrying\n", PACKAGES_LIST_FILE);
+					sleep(3);
+					continue;
+				}
+				else {
+					ERROR("inotify_add_watch failed: %s\n", strerror(errno));
+					return;
+				}
+			}
+			/* Watch above will tell us about any future changes, so
+			 * read the current state. */
+			if (read_package_list(global) == false) {
+				ERROR("read_package_list failed\n");
+				return;
+			}
+			active = true;
+		}
+		int event_pos = 0;
+		int res = read(nfd, event_buf, sizeof(event_buf));
+		if (res < (int) sizeof(*event)) {
+			if (errno == EINTR)
+				continue;
+			ERROR("failed to read inotify event: %s\n", strerror(errno));
+			return;
+		}
+		while (res >= (int) sizeof(*event)) {
+			int event_size;
+			event = (struct inotify_event *) (event_buf + event_pos);
+			TRACE("inotify event: %08x\n", event->mask);
+			if ((event->mask & IN_IGNORED) == IN_IGNORED) {
+				/* Previously watched file was deleted, probably due to move
+				 * that swapped in new data; re-arm the watch and read. */
+				active = false;
+			}
+			event_size = sizeof(*event) + event->len;
+			res -= event_size;
+			event_pos += event_size;
+		}
+	}
 }
 
 static int usage() {
-    LOG(ERROR) << "usage: sdcard [OPTIONS] <source_path> <label>"
-               << "    -u: specify UID to run as"
-               << "    -g: specify GID to run as"
-               << "    -U: specify user ID that owns device"
-               << "    -m: source_path is multi-user"
-               << "    -w: runtime write mount has full write access"
-               << "    -P: preserve owners on the lower file system"
-               << "    -o: obb dir doesn't need to be shared between users";
+     ERROR("usage: sdcard [OPTIONS] <source_path> <label>\n"
+           "    -u: specify UID to run as\n"
+           "    -g: specify GID to run as\n"
+           "    -U: specify user ID that owns device\n"
+           "    -m: source_path is multi-user\n"
+           "    -w: runtime write mount has full write access\n"
+          "\n");
     return 1;
 }
 
+static int fuse_setup(struct fuse* fuse, gid_t gid, mode_t mask) {
+	char opts[256];
+
+	fuse->fd = open("/dev/fuse", O_RDWR);
+	if (fuse->fd == -1) {
+		ERROR("failed to open fuse device: %s\n", strerror(errno));
+		return -1;
+	}
+
+	umount2(fuse->dest_path, MNT_DETACH);
+
+	snprintf(opts, sizeof(opts),
+		"fd=%i,rootmode=40000,default_permissions,allow_other,user_id=%d,group_id=%d",
+		fuse->fd, fuse->global->uid, fuse->global->gid);
+	if (mount("/dev/fuse", fuse->dest_path, "fuse", MS_NOSUID | MS_NODEV | MS_NOEXEC |
+		MS_NOATIME, opts) != 0) {
+		ERROR("failed to mount fuse filesystem: %s\n", strerror(errno));
+		return -1;
+	}
+
+	fuse->gid = gid;
+	fuse->mask = mask;
+
+	return 0;
+}
+
+static void run(const char* source_path, const char* label, uid_t uid,
+	gid_t gid, userid_t userid, bool multi_user, bool full_write) {
+	struct fuse_global global;
+	struct fuse fuse_default;
+	struct fuse fuse_read;
+	struct fuse fuse_write;
+	struct fuse fuse_full;
+	struct fuse_handler handler_default;
+	struct fuse_handler handler_read;
+	struct fuse_handler handler_write;
+	struct fuse_handler handler_full;
+	pthread_t thread_default;
+	pthread_t thread_read;
+	pthread_t thread_write;
+	pthread_t thread_full;
+
+	memset(&global, 0, sizeof(global));
+	memset(&fuse_default, 0, sizeof(fuse_default));
+	memset(&fuse_read, 0, sizeof(fuse_read));
+	memset(&fuse_write, 0, sizeof(fuse_write));
+	memset(&fuse_full, 0, sizeof(fuse_full));
+	memset(&handler_default, 0, sizeof(handler_default));
+	memset(&handler_read, 0, sizeof(handler_read));
+	memset(&handler_write, 0, sizeof(handler_write));
+	memset(&handler_full, 0, sizeof(handler_full));
+
+	pthread_mutex_init(&global.lock, NULL);
+	global.package_to_appid = hashmapCreate(256, str_hash, str_icase_equals);
+	global.uid = uid;
+	global.gid = gid;
+	global.multi_user = multi_user;
+	global.next_generation = 0;
+	global.inode_ctr = 1;
+
+	memset(&global.root, 0, sizeof(global.root));
+	global.root.nid = FUSE_ROOT_ID; /* 1 */
+	global.root.refcount = 2;
+	global.root.namelen = strlen(source_path);
+	global.root.name = strdup(source_path);
+	global.root.userid = userid;
+	global.root.uid = AID_ROOT;
+	global.root.under_android = false;
+
+	strcpy(global.source_path, source_path);
+
+	if (multi_user) {
+		global.root.perm = PERM_PRE_ROOT;
+		snprintf(global.obb_path, sizeof(global.obb_path), "%s/obb", source_path);
+	}
+	else {
+		global.root.perm = PERM_ROOT;
+		snprintf(global.obb_path, sizeof(global.obb_path), "%s/Android/obb", source_path);
+	}
+
+	fuse_default.global = &global;
+	fuse_read.global = &global;
+	fuse_write.global = &global;
+	fuse_full.global = &global;
+
+	global.fuse_default = &fuse_default;
+	global.fuse_read = &fuse_read;
+	global.fuse_write = &fuse_write;
+	global.fuse_full = &fuse_full;
+
+	snprintf(fuse_default.dest_path, PATH_MAX, "/mnt/runtime/default/%s", label);
+	snprintf(fuse_read.dest_path, PATH_MAX, "/mnt/runtime/read/%s", label);
+	snprintf(fuse_write.dest_path, PATH_MAX, "/mnt/runtime/write/%s", label);
+	snprintf(fuse_full.dest_path, PATH_MAX, "/mnt/runtime/full/%s", label);
+
+	handler_default.fuse = &fuse_default;
+	handler_read.fuse = &fuse_read;
+	handler_write.fuse = &fuse_write;
+	handler_full.fuse = &fuse_full;
+
+	handler_default.token = 0;
+	handler_read.token = 1;
+	handler_write.token = 2;
+	handler_full.token = 3;
+
+	umask(0);
+
+	if (multi_user) {
+		/* Multi-user storage is fully isolated per user, so "other"
+		 * permissions are completely masked off. */
+		if (fuse_setup(&fuse_default, AID_SDCARD_RW, 0006)
+			|| fuse_setup(&fuse_read, AID_EVERYBODY, 0027)
+			|| fuse_setup(&fuse_write, AID_EVERYBODY, full_write ? 0007 : 0027)
+			|| fuse_setup(&fuse_full, AID_EVERYBODY, 0007)) {
+			ERROR("failed to fuse_setup\n");
+			exit(1);
+		}
+	}
+	else {
+		/* Physical storage is readable by all users on device, but
+		 * the Android directories are masked off to a single user
+		 * deep inside attr_from_stat(). */
+		if (fuse_setup(&fuse_default, AID_SDCARD_RW, 0006)
+			|| fuse_setup(&fuse_read, AID_EVERYBODY, full_write ? 0027 : 0022)
+			|| fuse_setup(&fuse_write, AID_EVERYBODY, full_write ? 0007 : 0022)
+			|| fuse_setup(&fuse_full, AID_EVERYBODY, 0007)) {
+			ERROR("failed to fuse_setup\n");
+			exit(1);
+		}
+	}
+
+	/* Drop privs */
+	if (setgroups(sizeof(kGroups) / sizeof(kGroups[0]), kGroups) < 0) {
+		ERROR("cannot setgroups: %s\n", strerror(errno));
+		exit(1);
+	}
+	if (setgid(gid) < 0) {
+		ERROR("cannot setgid: %s\n", strerror(errno));
+		exit(1);
+	}
+	if (setuid(uid) < 0) {
+		ERROR("cannot setuid: %s\n", strerror(errno));
+		exit(1);
+	}
+
+	if (multi_user) {
+		fs_prepare_dir(global.obb_path, 0775, uid, gid);
+	}
+
+	if (pthread_create(&thread_default, NULL, start_handler, &handler_default)
+		|| pthread_create(&thread_read, NULL, start_handler, &handler_read)
+		|| pthread_create(&thread_write, NULL, start_handler, &handler_write)
+		|| pthread_create(&thread_full, NULL, start_handler, &handler_full)) {
+		ERROR("failed to pthread_create\n");
+		exit(1);
+	}
+
+	watch_package_list(&global);
+	ERROR("terminated prematurely\n");
+	exit(1);
+}
+#if 0
+static int sdcardfs_setup(const char *source_path, const char *dest_path, uid_t fsuid,
+	gid_t fsgid, bool multi_user, userid_t userid, gid_t gid, mode_t mask) {
+	char opts[256];
+
+	snprintf(opts, sizeof(opts),
+		"fsuid=%d,fsgid=%d,%smask=%d,userid=%d,gid=%d",
+		fsuid, fsgid, multi_user ? "multiuser," : "", mask, userid, gid);
+
+	if (mount(source_path, dest_path, "sdcardfs",
+		MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_NOATIME, opts) != 0) {
+		ERROR("failed to mount sdcardfs filesystem: %s\n", strerror(errno));
+		return -1;
+	}
+
+	return 0;
+}
+
+static void run_sdcardfs(const char* source_path, const char* label, uid_t uid,
+	gid_t gid, userid_t userid, bool multi_user, bool full_write) {
+	char dest_path_default[PATH_MAX];
+	char dest_path_read[PATH_MAX];
+	char dest_path_write[PATH_MAX];
+	char obb_path[PATH_MAX];
+	snprintf(dest_path_default, PATH_MAX, "/mnt/runtime/default/%s", label);
+	snprintf(dest_path_read, PATH_MAX, "/mnt/runtime/read/%s", label);
+	snprintf(dest_path_write, PATH_MAX, "/mnt/runtime/write/%s", label);
+
+	umask(0);
+	if (multi_user) {
+		/* Multi-user storage is fully isolated per user, so "other"
+		 * permissions are completely masked off. */
+		if (sdcardfs_setup(source_path, dest_path_default, uid, gid, multi_user, userid,
+			AID_SDCARD_RW, 0006)
+			|| sdcardfs_setup(source_path, dest_path_read, uid, gid, multi_user, userid,
+				AID_EVERYBODY, 0027)
+			|| sdcardfs_setup(source_path, dest_path_write, uid, gid, multi_user, userid,
+				AID_EVERYBODY, full_write ? 0007 : 0027)) {
+			ERROR("failed to fuse_setup\n");
+			exit(1);
+		}
+	}
+	else {
+		/* Physical storage is readable by all users on device, but
+		 * the Android directories are masked off to a single user
+		 * deep inside attr_from_stat(). */
+		if (sdcardfs_setup(source_path, dest_path_default, uid, gid, multi_user, userid,
+			AID_SDCARD_RW, 0006)
+			|| sdcardfs_setup(source_path, dest_path_read, uid, gid, multi_user, userid,
+				AID_EVERYBODY, full_write ? 0027 : 0022)
+			|| sdcardfs_setup(source_path, dest_path_write, uid, gid, multi_user, userid,
+				AID_EVERYBODY, full_write ? 0007 : 0022)) {
+			ERROR("failed to fuse_setup\n");
+			exit(1);
+		}
+	}
+
+	/* Drop privs */
+	if (setgroups(sizeof(kGroups) / sizeof(kGroups[0]), kGroups) < 0) {
+		ERROR("cannot setgroups: %s\n", strerror(errno));
+		exit(1);
+	}
+	if (setgid(gid) < 0) {
+		ERROR("cannot setgid: %s\n", strerror(errno));
+		exit(1);
+	}
+	if (setuid(uid) < 0) {
+		ERROR("cannot setuid: %s\n", strerror(errno));
+		exit(1);
+	}
+
+	if (multi_user) {
+		snprintf(obb_path, sizeof(obb_path), "%s/obb", source_path);
+		fs_prepare_dir(&obb_path[0], 0775, uid, gid);
+	}
+
+	exit(0);
+}
+#endif
+static bool supports_sdcardfs(void) {
+	FILE *fp;
+	char *buf = NULL;
+	size_t buflen = 0;
+
+	fp = fopen("/proc/filesystems", "r");
+	if (!fp) {
+		ERROR("Could not read /proc/filesystems, error: %s\n", strerror(errno));
+		return false;
+	}
+	while ((getline(&buf, &buflen, fp)) > 0) {
+		if (strstr(buf, "sdcardfs\n")) {
+			free(buf);
+			fclose(fp);
+			return true;
+		}
+	}
+	free(buf);
+	fclose(fp);
+	return false;
+}
+
+static bool should_use_sdcardfs(void) {
+	char property[PROPERTY_VALUE_MAX];
+
+	// Allow user to have a strong opinion about state
+	property_get(PROP_SDCARDFS_USER, property, "");
+	if (!strcmp(property, "force_on")) {
+		ALOGW("User explicitly enabled sdcardfs");
+		return supports_sdcardfs();
+	}
+	else if (!strcmp(property, "force_off")) {
+		ALOGW("User explicitly disabled sdcardfs");
+		return false;
+	}
+
+	// Fall back to device opinion about state
+	if (property_get_bool(PROP_SDCARDFS_DEVICE, false)) {
+		ALOGW("Device explicitly enabled sdcardfs");
+		return supports_sdcardfs();
+	}
+	else {
+		ALOGW("Device explicitly disabled sdcardfs");
+		return false;
+	}
+}
+
 int main(int argc, char **argv) {
-    const char *source_path = NULL;
-    const char *label = NULL;
-    uid_t uid = 0;
-    gid_t gid = 0;
-    userid_t userid = 0;
-    bool multi_user = false;
-    bool full_write = false;
-    bool derive_gid = false;
+	ALOGE("main start");
+	const char *source_path = NULL;
+	const char *label = NULL;
+	uid_t uid = 0;
+	gid_t gid = 0;
+	userid_t userid = 0;
+	bool multi_user = false;
+	bool full_write = false;
+	    bool derive_gid = false;
     bool default_normal = false;
-    bool unshared_obb = false;
-    int i;
-    struct rlimit rlim;
-    int fs_version;
-
-    setenv("ANDROID_LOG_TAGS", "*:v", 1);
-    android::base::InitLogging(argv, android::base::LogdLogger(android::base::SYSTEM));
-
-    int opt;
-    while ((opt = getopt(argc, argv, "u:g:U:mwGio")) != -1) {
-        switch (opt) {
-            case 'u':
-                uid = strtoul(optarg, NULL, 10);
-                break;
-            case 'g':
-                gid = strtoul(optarg, NULL, 10);
-                break;
-            case 'U':
-                userid = strtoul(optarg, NULL, 10);
-                break;
-            case 'm':
-                multi_user = true;
-                break;
-            case 'w':
-                full_write = true;
-                break;
-            case 'G':
-                derive_gid = true;
-                break;
-            case 'i':
-                default_normal = true;
-                break;
-            case 'o':
-                unshared_obb = true;
-                break;
-            case '?':
-            default:
-                LOG(ERROR) << "Unknown option: '" << opt << "'";
-                return usage();
-        }
-    }
-
-    for (i = optind; i < argc; i++) {
-        char* arg = argv[i];
-        if (!source_path) {
-            source_path = arg;
-        } else if (!label) {
-            label = arg;
-        } else {
-            LOG(ERROR) << "too many arguments";
-            return usage();
-        }
-    }
-
-    if (!source_path) {
-        LOG(ERROR) << "no source path specified";
-        return usage();
-    }
-    if (!label) {
-        LOG(ERROR) << "no label specified";
-        return usage();
-    }
-    if (!uid || !gid) {
-        LOG(ERROR) << "uid and gid must be nonzero";
-        return usage();
-    }
-
-    rlim.rlim_cur = 8192;
-    rlim.rlim_max = 8192;
-    if (setrlimit(RLIMIT_NOFILE, &rlim) == -1) {
-        PLOG(ERROR) << "setting RLIMIT_NOFILE failed";
-    }
-
-    while ((fs_read_atomic_int("/data/.layout_version", &fs_version) == -1) || (fs_version < 3)) {
-        LOG(ERROR) << "installd fs upgrade not yet complete; waiting...";
-        sleep(1);
-    }
-
-    run_sdcardfs(source_path, label, uid, gid, userid, multi_user, full_write, derive_gid,
-                 default_normal, unshared_obb, !should_use_sdcardfs());
-    return 1;
+	int i;
+	struct rlimit rlim;
+	int fs_version;
+
+	int opt;
+	while ((opt = getopt(argc, argv, "u:g:U:mwGio")) != -1) {
+		switch (opt) {
+		case 'u':
+			uid = strtoul(optarg, NULL, 10);
+			break;
+		case 'g':
+			gid = strtoul(optarg, NULL, 10);
+			break;
+		case 'U':
+			userid = strtoul(optarg, NULL, 10);
+			break;
+		case 'm':
+			multi_user = true;
+			break;
+		case 'w':
+			full_write = true;
+			break;
+        case 'G':
+            derive_gid = true;
+            break;
+        case 'i':
+            default_normal = true;
+            break;
+        case 'o':
+            break;
+		case '?':
+		default:
+			return usage();
+		}
+	}
+	ALOGE("main start 2");
+	for (i = optind; i < argc; i++) {
+		char* arg = argv[i];
+		if (!source_path) {
+			source_path = arg;
+		}
+		else if (!label) {
+			label = arg;
+		}
+		else {
+			ERROR("too many arguments\n");
+			return usage();
+		}
+	}
+ALOGE("main start 3");
+	if (!source_path) {
+		ERROR("no source path specified\n");
+		return usage();
+	}
+	if (!label) {
+		ERROR("no label specified\n");
+		return usage();
+	}
+	if (!uid || !gid) {
+		ERROR("uid and gid must be nonzero\n");
+		return usage();
+	}
+
+	rlim.rlim_cur = 8192;
+	rlim.rlim_max = 8192;
+	if (setrlimit(RLIMIT_NOFILE, &rlim)) {
+		ERROR("Error setting RLIMIT_NOFILE, errno = %d\n", errno);
+	}
+ALOGE("main start 4");
+	while ((fs_read_atomic_int("/data/.layout_version", &fs_version) == -1) || (fs_version < 3)) {
+		ERROR("installd fs upgrade not yet complete. Waiting...\n");
+		sleep(1);
+	}
+	if (should_use_sdcardfs()) {
+		ALOGE("should_use_sdcardfs");
+		// run_sdcardfs(source_path, label, uid, gid, userid, multi_user, full_write);
+	}
+	// else {
+		run(source_path, label, uid, gid, userid, multi_user, full_write);
+	// }
+	return 1;
 }
